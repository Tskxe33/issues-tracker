/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/easymde";
exports.ids = ["vendor-chunks/easymde"];
exports.modules = {

/***/ "(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js":
/*!***********************************************************!*\
  !*** ./node_modules/easymde/src/js/codemirror/tablist.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n\nCodeMirror.commands.tabAndIndentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentMore');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentLess');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvY29kZW1pcnJvci90YWJsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMscUVBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pc3N1ZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2Vhc3ltZGUvc3JjL2pzL2NvZGVtaXJyb3IvdGFibGlzdC5qcz9iY2NjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxudmFyIENvZGVNaXJyb3IgPSByZXF1aXJlKCdjb2RlbWlycm9yJyk7XG5cbkNvZGVNaXJyb3IuY29tbWFuZHMudGFiQW5kSW5kZW50TWFya2Rvd25MaXN0ID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgdmFyIHBvcyA9IHJhbmdlc1swXS5oZWFkO1xuICAgIHZhciBlb2xTdGF0ZSA9IGNtLmdldFN0YXRlQWZ0ZXIocG9zLmxpbmUpO1xuICAgIHZhciBpbkxpc3QgPSBlb2xTdGF0ZS5saXN0ICE9PSBmYWxzZTtcblxuICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoJ2luZGVudE1vcmUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbnNlcnRUYWInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BhY2VzID0gQXJyYXkoY20ub3B0aW9ucy50YWJTaXplICsgMSkuam9pbignICcpO1xuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHNwYWNlcyk7XG4gICAgfVxufTtcblxuQ29kZU1pcnJvci5jb21tYW5kcy5zaGlmdFRhYkFuZFVuaW5kZW50TWFya2Rvd25MaXN0ID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgdmFyIHBvcyA9IHJhbmdlc1swXS5oZWFkO1xuICAgIHZhciBlb2xTdGF0ZSA9IGNtLmdldFN0YXRlQWZ0ZXIocG9zLmxpbmUpO1xuICAgIHZhciBpbkxpc3QgPSBlb2xTdGF0ZS5saXN0ICE9PSBmYWxzZTtcblxuICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoJ2luZGVudExlc3MnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKSB7XG4gICAgICAgIGNtLmV4ZWNDb21tYW5kKCdpbnNlcnRUYWInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BhY2VzID0gQXJyYXkoY20ub3B0aW9ucy50YWJTaXplICsgMSkuam9pbignICcpO1xuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHNwYWNlcyk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/src/js/easymde.js":
/*!************************************************!*\
  !*** ./node_modules/easymde/src/js/easymde.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n__webpack_require__(/*! codemirror/addon/edit/continuelist.js */ \"(ssr)/./node_modules/codemirror/addon/edit/continuelist.js\");\n__webpack_require__(/*! ./codemirror/tablist */ \"(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\");\n__webpack_require__(/*! codemirror/addon/display/fullscreen.js */ \"(ssr)/./node_modules/codemirror/addon/display/fullscreen.js\");\n__webpack_require__(/*! codemirror/mode/markdown/markdown.js */ \"(ssr)/./node_modules/codemirror/mode/markdown/markdown.js\");\n__webpack_require__(/*! codemirror/addon/mode/overlay.js */ \"(ssr)/./node_modules/codemirror/addon/mode/overlay.js\");\n__webpack_require__(/*! codemirror/addon/display/placeholder.js */ \"(ssr)/./node_modules/codemirror/addon/display/placeholder.js\");\n__webpack_require__(/*! codemirror/addon/display/autorefresh.js */ \"(ssr)/./node_modules/codemirror/addon/display/autorefresh.js\");\n__webpack_require__(/*! codemirror/addon/selection/mark-selection.js */ \"(ssr)/./node_modules/codemirror/addon/selection/mark-selection.js\");\n__webpack_require__(/*! codemirror/addon/search/searchcursor.js */ \"(ssr)/./node_modules/codemirror/addon/search/searchcursor.js\");\n__webpack_require__(/*! codemirror/mode/gfm/gfm.js */ \"(ssr)/./node_modules/codemirror/mode/gfm/gfm.js\");\n__webpack_require__(/*! codemirror/mode/xml/xml.js */ \"(ssr)/./node_modules/codemirror/mode/xml/xml.js\");\nvar CodeMirrorSpellChecker = __webpack_require__(/*! codemirror-spell-checker */ \"(ssr)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js\");\nvar marked = (__webpack_require__(/*! marked */ \"(ssr)/./node_modules/marked/lib/marked.cjs\").marked);\n\n\n// Some variables\nvar isMac = /Mac/.test(navigator.platform);\nvar anchorToExternalRegex = new RegExp(/(<a.*?https?:\\/\\/.*?[^a]>)+?/g);\n\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\nvar bindings = {\n    'toggleBold': toggleBold,\n    'toggleItalic': toggleItalic,\n    'drawLink': drawLink,\n    'toggleHeadingSmaller': toggleHeadingSmaller,\n    'toggleHeadingBigger': toggleHeadingBigger,\n    'drawImage': drawImage,\n    'toggleBlockquote': toggleBlockquote,\n    'toggleOrderedList': toggleOrderedList,\n    'toggleUnorderedList': toggleUnorderedList,\n    'toggleCodeBlock': toggleCodeBlock,\n    'togglePreview': togglePreview,\n    'toggleStrikethrough': toggleStrikethrough,\n    'toggleHeading1': toggleHeading1,\n    'toggleHeading2': toggleHeading2,\n    'toggleHeading3': toggleHeading3,\n    'toggleHeading4': toggleHeading4,\n    'toggleHeading5': toggleHeading5,\n    'toggleHeading6': toggleHeading6,\n    'cleanBlock': cleanBlock,\n    'drawTable': drawTable,\n    'drawHorizontalRule': drawHorizontalRule,\n    'undo': undo,\n    'redo': redo,\n    'toggleSideBySide': toggleSideBySide,\n    'toggleFullScreen': toggleFullScreen,\n};\n\nvar shortcuts = {\n    'toggleBold': 'Cmd-B',\n    'toggleItalic': 'Cmd-I',\n    'drawLink': 'Cmd-K',\n    'toggleHeadingSmaller': 'Cmd-H',\n    'toggleHeadingBigger': 'Shift-Cmd-H',\n    'toggleHeading1': 'Ctrl+Alt+1',\n    'toggleHeading2': 'Ctrl+Alt+2',\n    'toggleHeading3': 'Ctrl+Alt+3',\n    'toggleHeading4': 'Ctrl+Alt+4',\n    'toggleHeading5': 'Ctrl+Alt+5',\n    'toggleHeading6': 'Ctrl+Alt+6',\n    'cleanBlock': 'Cmd-E',\n    'drawImage': 'Cmd-Alt-I',\n    'toggleBlockquote': 'Cmd-\\'',\n    'toggleOrderedList': 'Cmd-Alt-L',\n    'toggleUnorderedList': 'Cmd-L',\n    'toggleCodeBlock': 'Cmd-Alt-C',\n    'togglePreview': 'Cmd-P',\n    'toggleSideBySide': 'F9',\n    'toggleFullScreen': 'F11',\n};\n\nvar getBindingName = function (f) {\n    for (var key in bindings) {\n        if (bindings[key] === f) {\n            return key;\n        }\n    }\n    return null;\n};\n\nvar isMobile = function () {\n    var check = false;\n    (function (a) {\n        if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4))) check = true;\n    })(navigator.userAgent || navigator.vendor || window.opera);\n    return check;\n};\n\n/**\n * Modify HTML to add 'target=\"_blank\"' to links so they open in new tabs by default.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction addAnchorTargetBlank(htmlText) {\n    var match;\n    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {\n        // With only one capture group in the RegExp, we can safely take the first index from the match.\n        var linkString = match[0];\n\n        if (linkString.indexOf('target=') === -1) {\n            var fixedLinkString = linkString.replace(/>$/, ' target=\"_blank\">');\n            htmlText = htmlText.replace(linkString, fixedLinkString);\n        }\n    }\n    return htmlText;\n}\n\n/**\n * Modify HTML to remove the list-style when rendering checkboxes.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction removeListStyleWhenCheckbox(htmlText) {\n\n    var parser = new DOMParser();\n    var htmlDoc = parser.parseFromString(htmlText, 'text/html');\n    var listItems = htmlDoc.getElementsByTagName('li');\n\n    for (var i = 0; i < listItems.length; i++) {\n        var listItem = listItems[i];\n\n        for (var j = 0; j < listItem.children.length; j++) {\n            var listItemChild = listItem.children[j];\n\n            if (listItemChild instanceof HTMLInputElement && listItemChild.type === 'checkbox') {\n                // From Github: margin: 0 .2em .25em -1.6em;\n                listItem.style.marginLeft = '-1.5em';\n                listItem.style.listStyleType = 'none';\n            }\n        }\n    }\n\n    return htmlDoc.documentElement.innerHTML;\n}\n\n/**\n * Fix shortcut. Mac use Command, others use Ctrl.\n */\nfunction fixShortcut(name) {\n    if (isMac) {\n        name = name.replace('Ctrl', 'Cmd');\n    } else {\n        name = name.replace('Cmd', 'Ctrl');\n    }\n    return name;\n}\n\n/**\n * Create dropdown block\n */\nfunction createToolbarDropdown(options, enableTooltips, shortcuts, parent) {\n    var el = createToolbarButton(options, false, enableTooltips, shortcuts, 'button', parent);\n    el.classList.add('easymde-dropdown');\n\n    el.onclick = function () {\n        el.focus();\n    };\n\n    var content = document.createElement('div');\n    content.className = 'easymde-dropdown-content';\n    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {\n\n        var child = options.children[childrenIndex];\n        var childElement;\n\n        if (typeof child === 'string' && child in toolbarBuiltInButtons) {\n            childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts, 'button', parent);\n        } else {\n            childElement = createToolbarButton(child, true, enableTooltips, shortcuts, 'button', parent);\n        }\n\n        childElement.addEventListener('click', function (e) { e.stopPropagation(); }, false);\n        content.appendChild(childElement);\n    }\n    el.appendChild(content);\n    return el;\n}\n\n/**\n * Create button element for toolbar.\n */\nfunction createToolbarButton(options, enableActions, enableTooltips, shortcuts, markup, parent) {\n    options = options || {};\n    var el = document.createElement(markup);\n\n    // Add 'custom' attributes as early as possible, so that 'official' attributes will never be overwritten.\n    if (options.attributes) {\n        for (var attribute in options.attributes) {\n            if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {\n                el.setAttribute(attribute, options.attributes[attribute]);\n            }\n        }\n    }\n\n    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + '-' : '';\n    el.className = classNamePrefix + options.name;\n    el.setAttribute('type', markup);\n    enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;\n\n    if (options.text) {\n        el.innerText = options.text;\n    }\n\n    // Properly handle custom shortcuts\n    if (options.name && options.name in shortcuts) {\n        bindings[options.name] = options.action;\n    }\n\n    if (options.title && enableTooltips) {\n        el.title = createTooltip(options.title, options.action, shortcuts);\n\n        if (isMac) {\n            el.title = el.title.replace('Ctrl', '⌘');\n            el.title = el.title.replace('Alt', '⌥');\n        }\n    }\n\n    if (options.title) {\n        el.setAttribute('aria-label', options.title);\n    }\n\n    if (options.noDisable) {\n        el.classList.add('no-disable');\n    }\n\n    if (options.noMobile) {\n        el.classList.add('no-mobile');\n    }\n\n    // Prevent errors if there is no class name in custom options\n    var classNameParts = [];\n    if (typeof options.className !== 'undefined') {\n        classNameParts = options.className.split(' ');\n    }\n\n    // Provide backwards compatibility with simple-markdown-editor by adding custom classes to the button.\n    var iconClasses = [];\n    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {\n        var classNamePart = classNameParts[classNameIndex];\n        // Split icon classes from the button.\n        // Regex will detect \"fa\", \"fas\", \"fa-something\" and \"fa-some-icon-1\", but not \"fanfare\".\n        if (classNamePart.match(/^fa([srlb]|(-[\\w-]*)|$)/)) {\n            iconClasses.push(classNamePart);\n        } else {\n            el.classList.add(classNamePart);\n        }\n    }\n\n    el.tabIndex = -1;\n\n    if (iconClasses.length > 0) {\n        // Create icon element and append as a child to the button\n        var icon = document.createElement('i');\n        for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {\n            var iconClass = iconClasses[iconClassIndex];\n            icon.classList.add(iconClass);\n        }\n        el.appendChild(icon);\n    }\n\n    // If there is a custom icon markup set, use that\n    if (typeof options.icon !== 'undefined') {\n        el.innerHTML = options.icon;\n    }\n\n    if (options.action && enableActions) {\n        if (typeof options.action === 'function') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                options.action(parent);\n            };\n        } else if (typeof options.action === 'string') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                window.open(options.action, '_blank');\n            };\n        }\n    }\n\n    return el;\n}\n\nfunction createSep() {\n    var el = document.createElement('i');\n    el.className = 'separator';\n    el.innerHTML = '|';\n    return el;\n}\n\nfunction createTooltip(title, action, shortcuts) {\n    var actionName;\n    var tooltip = title;\n\n    if (action) {\n        actionName = getBindingName(action);\n        if (shortcuts[actionName]) {\n            tooltip += ' (' + fixShortcut(shortcuts[actionName]) + ')';\n        }\n    }\n\n    return tooltip;\n}\n\n/**\n * The state of CodeMirror at the given position.\n */\nfunction getState(cm, pos) {\n    pos = pos || cm.getCursor('start');\n    var stat = cm.getTokenAt(pos);\n    if (!stat.type) return {};\n\n    var types = stat.type.split(' ');\n\n    var ret = {},\n        data, text;\n    for (var i = 0; i < types.length; i++) {\n        data = types[i];\n        if (data === 'strong') {\n            ret.bold = true;\n        } else if (data === 'variable-2') {\n            text = cm.getLine(pos.line);\n            if (/^\\s*\\d+\\.\\s/.test(text)) {\n                ret['ordered-list'] = true;\n            } else {\n                ret['unordered-list'] = true;\n            }\n        } else if (data === 'atom') {\n            ret.quote = true;\n        } else if (data === 'em') {\n            ret.italic = true;\n        } else if (data === 'quote') {\n            ret.quote = true;\n        } else if (data === 'strikethrough') {\n            ret.strikethrough = true;\n        } else if (data === 'comment') {\n            ret.code = true;\n        } else if (data === 'link' && !ret.image) {\n            ret.link = true;\n        } else if (data === 'image') {\n            ret.image = true;\n        } else if (data.match(/^header(-[1-6])?$/)) {\n            ret[data.replace('header', 'heading')] = true;\n        }\n    }\n    return ret;\n}\n\n\n// Saved overflow setting\nvar saved_overflow = '';\n\n/**\n * Toggle full screen of the editor.\n * @param {EasyMDE} editor\n */\nfunction toggleFullScreen(editor) {\n    // Set fullscreen\n    var cm = editor.codemirror;\n    cm.setOption('fullScreen', !cm.getOption('fullScreen'));\n\n\n    // Prevent scrolling on body during fullscreen active\n    if (cm.getOption('fullScreen')) {\n        saved_overflow = document.body.style.overflow;\n        document.body.style.overflow = 'hidden';\n    } else {\n        document.body.style.overflow = saved_overflow;\n    }\n\n    var wrapper = cm.getWrapperElement();\n    var sidebyside = wrapper.nextSibling;\n\n    if (sidebyside.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, apply classes as needed\n            var easyMDEContainer = wrapper.parentNode;\n            if (cm.getOption('fullScreen')) {\n                easyMDEContainer.classList.remove('sided--no-fullscreen');\n            } else {\n                easyMDEContainer.classList.add('sided--no-fullscreen');\n            }\n        } else {\n            toggleSideBySide(editor);\n        }\n    }\n\n    if (editor.options.onToggleFullScreen) {\n        editor.options.onToggleFullScreen(cm.getOption('fullScreen') || false);\n    }\n\n    // Remove or set maxHeight\n    if (typeof editor.options.maxHeight !== 'undefined') {\n        if (cm.getOption('fullScreen')) {\n            cm.getScrollerElement().style.removeProperty('height');\n            sidebyside.style.removeProperty('height');\n        } else {\n            cm.getScrollerElement().style.height = editor.options.maxHeight;\n            editor.setPreviewMaxHeight();\n        }\n    }\n\n    // Update toolbar class\n    editor.toolbar_div.classList.toggle('fullscreen');\n\n    // Update toolbar button\n    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {\n        var toolbarButton = editor.toolbarElements.fullscreen;\n        toolbarButton.classList.toggle('active');\n    }\n}\n\n\n/**\n * Action for toggling bold.\n * @param {EasyMDE} editor\n */\nfunction toggleBold(editor) {\n    _toggleBlock(editor, 'bold', editor.options.blockStyles.bold);\n}\n\n\n/**\n * Action for toggling italic.\n * @param {EasyMDE} editor\n */\nfunction toggleItalic(editor) {\n    _toggleBlock(editor, 'italic', editor.options.blockStyles.italic);\n}\n\n\n/**\n * Action for toggling strikethrough.\n * @param {EasyMDE} editor\n */\nfunction toggleStrikethrough(editor) {\n    _toggleBlock(editor, 'strikethrough', '~~');\n}\n\n/**\n * Action for toggling code block.\n * @param {EasyMDE} editor\n */\nfunction toggleCodeBlock(editor) {\n    var fenceCharsToInsert = editor.options.blockStyles.code;\n\n    function fencing_line(line) {\n        /* return true, if this is a ``` or ~~~ line */\n        if (typeof line !== 'object') {\n            throw 'fencing_line() takes a \\'line\\' object (not a line number, or line text).  Got: ' + typeof line + ': ' + line;\n        }\n        return line.styles && line.styles[2] && line.styles[2].indexOf('formatting-code-block') !== -1;\n    }\n\n    function token_state(token) {\n        // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\n        return token.state.base.base || token.state.base;\n    }\n\n    function code_type(cm, line_num, line, firstTok, lastTok) {\n        /*\n         * Return \"single\", \"indented\", \"fenced\" or false\n         *\n         * cm and line_num are required.  Others are optional for efficiency\n         *   To check in the middle of a line, pass in firstTok yourself.\n         */\n        line = line || cm.getLineHandle(line_num);\n        firstTok = firstTok || cm.getTokenAt({\n            line: line_num,\n            ch: 1,\n        });\n        lastTok = lastTok || (!!line.text && cm.getTokenAt({\n            line: line_num,\n            ch: line.text.length - 1,\n        }));\n        var types = firstTok.type ? firstTok.type.split(' ') : [];\n        if (lastTok && token_state(lastTok).indentedCode) {\n            // have to check last char, since first chars of first line aren\"t marked as indented\n            return 'indented';\n        } else if (types.indexOf('comment') === -1) {\n            // has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\n            return false;\n        } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\n            return 'fenced';\n        } else {\n            return 'single';\n        }\n    }\n\n    function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\n        var start_line_sel = cur_start.line + 1,\n            end_line_sel = cur_end.line + 1,\n            sel_multi = cur_start.line !== cur_end.line,\n            repl_start = fenceCharsToInsert + '\\n',\n            repl_end = '\\n' + fenceCharsToInsert;\n        if (sel_multi) {\n            end_line_sel++;\n        }\n        // handle last char including \\n or not\n        if (sel_multi && cur_end.ch === 0) {\n            repl_end = fenceCharsToInsert + '\\n';\n            end_line_sel--;\n        }\n        _replaceSelection(cm, false, [repl_start, repl_end]);\n        cm.setSelection({\n            line: start_line_sel,\n            ch: 0,\n        }, {\n            line: end_line_sel,\n            ch: 0,\n        });\n    }\n\n    var cm = editor.codemirror,\n        cur_start = cm.getCursor('start'),\n        cur_end = cm.getCursor('end'),\n        tok = cm.getTokenAt({\n            line: cur_start.line,\n            ch: cur_start.ch || 1,\n        }), // avoid ch 0 which is a cursor pos but not token\n        line = cm.getLineHandle(cur_start.line),\n        is_code = code_type(cm, cur_start.line, line, tok);\n    var block_start, block_end, lineCount;\n\n    if (is_code === 'single') {\n        // similar to some EasyMDE _toggleBlock logic\n        var start = line.text.slice(0, cur_start.ch).replace('`', ''),\n            end = line.text.slice(cur_start.ch).replace('`', '');\n        cm.replaceRange(start + end, {\n            line: cur_start.line,\n            ch: 0,\n        }, {\n            line: cur_start.line,\n            ch: 99999999999999,\n        });\n        cur_start.ch--;\n        if (cur_start !== cur_end) {\n            cur_end.ch--;\n        }\n        cm.setSelection(cur_start, cur_end);\n        cm.focus();\n    } else if (is_code === 'fenced') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n\n            // find the fenced line so we know what type it is (tilde, backticks, number of them)\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (fencing_line(line)) {\n                    break;\n                }\n            }\n            var fencedTok = cm.getTokenAt({\n                line: block_start,\n                ch: 1,\n            });\n            var fence_chars = token_state(fencedTok).fencedChars;\n            var start_text, start_line;\n            var end_text, end_line;\n            // check for selection going up against fenced lines, in which case we don't want to add more fencing\n            if (fencing_line(cm.getLineHandle(cur_start.line))) {\n                start_text = '';\n                start_line = cur_start.line;\n            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {\n                start_text = '';\n                start_line = cur_start.line - 1;\n            } else {\n                start_text = fence_chars + '\\n';\n                start_line = cur_start.line;\n            }\n            if (fencing_line(cm.getLineHandle(cur_end.line))) {\n                end_text = '';\n                end_line = cur_end.line;\n                if (cur_end.ch === 0) {\n                    end_line += 1;\n                }\n            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\n                end_text = '';\n                end_line = cur_end.line + 1;\n            } else {\n                end_text = fence_chars + '\\n';\n                end_line = cur_end.line + 1;\n            }\n            if (cur_end.ch === 0) {\n                // full last line selected, putting cursor at beginning of next\n                end_line -= 1;\n            }\n            cm.operation(function () {\n                // end line first, so that line numbers don't change\n                cm.replaceRange(end_text, {\n                    line: end_line,\n                    ch: 0,\n                }, {\n                    line: end_line + (end_text ? 0 : 1),\n                    ch: 0,\n                });\n                cm.replaceRange(start_text, {\n                    line: start_line,\n                    ch: 0,\n                }, {\n                    line: start_line + (start_text ? 0 : 1),\n                    ch: 0,\n                });\n            });\n            cm.setSelection({\n                line: start_line + (start_text ? 1 : 0),\n                ch: 0,\n            }, {\n                line: end_line + (start_text ? 1 : -1),\n                ch: 0,\n            });\n            cm.focus();\n        } else {\n            // no selection, search for ends of this fenced block\n            var search_from = cur_start.line;\n            if (fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line\n                if (code_type(cm, cur_start.line + 1) === 'fenced') {\n                    block_start = cur_start.line;\n                    search_from = cur_start.line + 1; // for searching for \"end\"\n                } else {\n                    block_end = cur_start.line;\n                    search_from = cur_start.line - 1; // for searching for \"start\"\n                }\n            }\n            if (block_start === undefined) {\n                for (block_start = search_from; block_start >= 0; block_start--) {\n                    line = cm.getLineHandle(block_start);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            if (block_end === undefined) {\n                lineCount = cm.lineCount();\n                for (block_end = search_from; block_end < lineCount; block_end++) {\n                    line = cm.getLineHandle(block_end);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            cm.operation(function () {\n                cm.replaceRange('', {\n                    line: block_start,\n                    ch: 0,\n                }, {\n                    line: block_start + 1,\n                    ch: 0,\n                });\n                cm.replaceRange('', {\n                    line: block_end - 1,\n                    ch: 0,\n                }, {\n                    line: block_end,\n                    ch: 0,\n                });\n            });\n            cm.focus();\n        }\n    } else if (is_code === 'indented') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n            block_start = cur_start.line;\n            block_end = cur_end.line;\n            if (cur_end.ch === 0) {\n                block_end--;\n            }\n        } else {\n            // no selection, search for ends of this indented block\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_start, line) !== 'indented') {\n                        block_start += 1;\n                        break;\n                    }\n                }\n            }\n            lineCount = cm.lineCount();\n            for (block_end = cur_start.line; block_end < lineCount; block_end++) {\n                line = cm.getLineHandle(block_end);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_end, line) !== 'indented') {\n                        block_end -= 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\n        // insert a blank line so that the next line(s) continue to be indented code\n        var next_line = cm.getLineHandle(block_end + 1),\n            next_line_last_tok = next_line && cm.getTokenAt({\n                line: block_end + 1,\n                ch: next_line.text.length - 1,\n            }),\n            next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\n        if (next_line_indented) {\n            cm.replaceRange('\\n', {\n                line: block_end + 1,\n                ch: 0,\n            });\n        }\n\n        for (var i = block_start; i <= block_end; i++) {\n            cm.indentLine(i, 'subtract'); // TODO: this doesn't get tracked in the history, so can't be undone :(\n        }\n        cm.focus();\n    } else {\n        // insert code formatting\n        var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);\n        var sel_multi = cur_start.line !== cur_end.line;\n        if (no_sel_and_starting_of_line || sel_multi) {\n            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\n        } else {\n            _replaceSelection(cm, false, ['`', '`']);\n        }\n    }\n}\n\n/**\n * Action for toggling blockquote.\n */\nfunction toggleBlockquote(editor) {\n    _toggleLine(editor.codemirror, 'quote');\n}\n\n/**\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\n */\nfunction toggleHeadingSmaller(editor) {\n    _toggleHeading(editor.codemirror, 'smaller');\n}\n\n/**\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\n */\nfunction toggleHeadingBigger(editor) {\n    _toggleHeading(editor.codemirror, 'bigger');\n}\n\n/**\n * Action for toggling heading size 1\n */\nfunction toggleHeading1(editor) {\n    _toggleHeading(editor.codemirror, undefined, 1);\n}\n\n/**\n * Action for toggling heading size 2\n */\nfunction toggleHeading2(editor) {\n    _toggleHeading(editor.codemirror, undefined, 2);\n}\n\n/**\n * Action for toggling heading size 3\n */\nfunction toggleHeading3(editor) {\n    _toggleHeading(editor.codemirror, undefined, 3);\n}\n\n/**\n * Action for toggling heading size 4\n */\nfunction toggleHeading4(editor) {\n    _toggleHeading(editor.codemirror, undefined, 4);\n}\n\n/**\n * Action for toggling heading size 5\n */\nfunction toggleHeading5(editor) {\n    _toggleHeading(editor.codemirror, undefined, 5);\n}\n\n/**\n * Action for toggling heading size 6\n */\nfunction toggleHeading6(editor) {\n    _toggleHeading(editor.codemirror, undefined, 6);\n}\n\n\n/**\n * Action for toggling ul.\n */\nfunction toggleUnorderedList(editor) {\n    var cm = editor.codemirror;\n\n    var listStyle = '*'; // Default\n    if (['-', '+', '*'].includes(editor.options.unorderedListStyle)) {\n        listStyle = editor.options.unorderedListStyle;\n    }\n\n    _toggleLine(cm, 'unordered-list', listStyle);\n}\n\n\n/**\n * Action for toggling ol.\n */\nfunction toggleOrderedList(editor) {\n    _toggleLine(editor.codemirror, 'ordered-list');\n}\n\n/**\n * Action for clean block (remove headline, list, blockquote code, markers)\n */\nfunction cleanBlock(editor) {\n    _cleanBlock(editor.codemirror);\n}\n\n/**\n * Action for drawing a link.\n * @param {EasyMDE} editor\n */\nfunction drawLink(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.link, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'link', options.insertTexts.link, url);\n}\n\n/**\n * Action for drawing an img.\n * @param {EasyMDE} editor\n */\nfunction drawImage(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.image, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'image', options.insertTexts.image, url);\n}\n\n/**\n * Encode and escape URLs to prevent breaking up rendered Markdown links.\n * @param {string} url The url of the link or image\n */\nfunction escapePromptURL(url) {\n    return encodeURI(url).replace(/([\\\\()])/g, '\\\\$1');\n}\n\n/**\n * Action for opening the browse-file window to upload an image to a server.\n * @param {EasyMDE} editor The EasyMDE object\n */\nfunction drawUploadedImage(editor) {\n    // TODO: Draw the image template with a fake url? ie: '![](importing foo.png...)'\n    editor.openBrowseFileWindow();\n}\n\n/**\n * Action executed after an image have been successfully imported on the server.\n * @param {EasyMDE} editor The EasyMDE object\n * @param {string} url The url of the uploaded image\n */\nfunction afterImageUploaded(editor, url) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    var imageName = url.substr(url.lastIndexOf('/') + 1);\n    var ext = imageName.substring(imageName.lastIndexOf('.') + 1).replace(/\\?.*$/, '').toLowerCase();\n\n    // Check if media is an image\n    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'apng', 'avif', 'webp'].includes(ext)) {\n        _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);\n    } else {\n        var text_link = options.insertTexts.link;\n        text_link[0] = '[' + imageName;\n        _replaceSelection(cm, stat.link, text_link, url);\n    }\n\n    // show uploaded image filename for 1000ms\n    editor.updateStatusBar('upload-image', editor.options.imageTexts.sbOnUploaded.replace('#image_name#', imageName));\n    setTimeout(function () {\n        editor.updateStatusBar('upload-image', editor.options.imageTexts.sbInit);\n    }, 1000);\n}\n\n/**\n * Action for drawing a table.\n * @param {EasyMDE} editor\n */\nfunction drawTable(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.table, options.insertTexts.table);\n}\n\n/**\n * Action for drawing a horizontal rule.\n * @param {EasyMDE} editor\n */\nfunction drawHorizontalRule(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\n}\n\n\n/**\n * Undo action.\n * @param {EasyMDE} editor\n */\nfunction undo(editor) {\n    var cm = editor.codemirror;\n    cm.undo();\n    cm.focus();\n}\n\n\n/**\n * Redo action.\n * @param {EasyMDE} editor\n */\nfunction redo(editor) {\n    var cm = editor.codemirror;\n    cm.redo();\n    cm.focus();\n}\n\n\n/**\n * Toggle side by side preview\n * @param {EasyMDE} editor\n */\nfunction toggleSideBySide(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    var toolbarButton = editor.toolbarElements && editor.toolbarElements['side-by-side'];\n    var useSideBySideListener = false;\n\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (preview.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, remove classes when hiding side\n            easyMDEContainer.classList.remove('sided--no-fullscreen');\n        }\n        preview.classList.remove('editor-preview-active-side');\n        if (toolbarButton) toolbarButton.classList.remove('active');\n        wrapper.classList.remove('CodeMirror-sided');\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            if (!cm.getOption('fullScreen')) {\n                if (editor.options.sideBySideFullscreen === false) {\n                    // if side-by-side not-fullscreen ok, add classes when not fullscreen and showing side\n                    easyMDEContainer.classList.add('sided--no-fullscreen');\n                } else {\n                    toggleFullScreen(editor);\n                }\n            }\n            preview.classList.add('editor-preview-active-side');\n        }, 1);\n        if (toolbarButton) toolbarButton.classList.add('active');\n        wrapper.classList.add('CodeMirror-sided');\n        useSideBySideListener = true;\n    }\n\n    // Hide normal preview if active\n    var previewNormal = wrapper.lastChild;\n    if (previewNormal.classList.contains('editor-preview-active')) {\n        previewNormal.classList.remove('editor-preview-active');\n        var toolbar = editor.toolbarElements.preview;\n        var toolbar_div = editor.toolbar_div;\n        toolbar.classList.remove('active');\n        toolbar_div.classList.remove('disabled-for-preview');\n    }\n\n    var sideBySideRenderingFunction = function () {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n    };\n\n    if (!cm.sideBySideRenderingFunction) {\n        cm.sideBySideRenderingFunction = sideBySideRenderingFunction;\n    }\n\n    if (useSideBySideListener) {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n        cm.on('update', cm.sideBySideRenderingFunction);\n    } else {\n        cm.off('update', cm.sideBySideRenderingFunction);\n    }\n\n    // Refresh to fix selection being off (#309)\n    cm.refresh();\n}\n\n\n/**\n * Preview action.\n * @param {EasyMDE} editor\n */\nfunction togglePreview(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var toolbar_div = editor.toolbar_div;\n    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\n    var preview = wrapper.lastChild;\n\n    // Turn off side by side if needed\n    var sidebyside = cm.getWrapperElement().nextSibling;\n    if (sidebyside.classList.contains('editor-preview-active-side'))\n        toggleSideBySide(editor);\n\n    if (!preview || !preview.classList.contains('editor-preview-full')) {\n\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-full';\n\n        if (editor.options.previewClass) {\n\n            if (Array.isArray(editor.options.previewClass)) {\n                for (var i = 0; i < editor.options.previewClass.length; i++) {\n                    preview.classList.add(editor.options.previewClass[i]);\n                }\n\n            } else if (typeof editor.options.previewClass === 'string') {\n                preview.classList.add(editor.options.previewClass);\n            }\n        }\n\n        wrapper.appendChild(preview);\n    }\n\n    if (preview.classList.contains('editor-preview-active')) {\n        preview.classList.remove('editor-preview-active');\n        if (toolbar) {\n            toolbar.classList.remove('active');\n            toolbar_div.classList.remove('disabled-for-preview');\n        }\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            preview.classList.add('editor-preview-active');\n        }, 1);\n        if (toolbar) {\n            toolbar.classList.add('active');\n            toolbar_div.classList.add('disabled-for-preview');\n        }\n    }\n\n    var preview_result = editor.options.previewRender(editor.value(), preview);\n    if (preview_result !== null) {\n        preview.innerHTML = preview_result;\n    }\n\n}\n\nfunction _replaceSelection(cm, active, startEnd, url) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var text;\n    var start = startEnd[0];\n    var end = startEnd[1];\n    var startPoint = {},\n        endPoint = {};\n    Object.assign(startPoint, cm.getCursor('start'));\n    Object.assign(endPoint, cm.getCursor('end'));\n    if (url) {\n        start = start.replace('#url#', url);  // url is in start for upload-image\n        end = end.replace('#url#', url);\n    }\n    if (active) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        });\n    } else {\n        text = cm.getSelection();\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start.length;\n        if (startPoint !== endPoint) {\n            endPoint.ch += start.length;\n        }\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n\nfunction _toggleHeading(cm, direction, size) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            var currHeadingLevel = text.search(/[^#]/);\n\n            if (direction !== undefined) {\n                if (currHeadingLevel <= 0) {\n                    if (direction == 'bigger') {\n                        text = '###### ' + text;\n                    } else {\n                        text = '# ' + text;\n                    }\n                } else if (currHeadingLevel == 6 && direction == 'smaller') {\n                    text = text.substr(7);\n                } else if (currHeadingLevel == 1 && direction == 'bigger') {\n                    text = text.substr(2);\n                } else {\n                    if (direction == 'bigger') {\n                        text = text.substr(1);\n                    } else {\n                        text = '#' + text;\n                    }\n                }\n            } else {\n                if (currHeadingLevel <= 0) {\n                    text = '#'.repeat(size) + ' ' + text;\n                } else if (currHeadingLevel == size) {\n                    text = text.substr(currHeadingLevel + 1);\n                } else {\n                    text = '#'.repeat(size) + ' ' + text.substr(currHeadingLevel + 1);\n                }\n            }\n\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n\nfunction _toggleLine(cm, name, liststyle) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var listRegexp = /^(\\s*)(\\*|-|\\+|\\d*\\.)(\\s+)/;\n    var whitespacesRegexp = /^\\s*/;\n\n    var stat = getState(cm);\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var repl = {\n        'quote': /^(\\s*)>\\s+/,\n        'unordered-list': listRegexp,\n        'ordered-list': listRegexp,\n    };\n\n    var _getChar = function (name, i) {\n        var map = {\n            'quote': '>',\n            'unordered-list': liststyle,\n            'ordered-list': '%%i.',\n        };\n\n        return map[name].replace('%%i', i);\n    };\n\n    var _checkChar = function (name, char) {\n        var map = {\n            'quote': '>',\n            'unordered-list': '\\\\' + liststyle,\n            'ordered-list': '\\\\d+.',\n        };\n        var rt = new RegExp(map[name]);\n\n        return char && rt.test(char);\n    };\n\n    var _toggle = function (name, text, untoggleOnly) {\n        var arr = listRegexp.exec(text);\n        var char = _getChar(name, line);\n        if (arr !== null) {\n            if (_checkChar(name, arr[2])) {\n                char = '';\n            }\n            text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, '').replace(repl[name], '$1');\n        } else if (untoggleOnly == false) {\n            text = char + ' ' + text;\n        }\n        return text;\n    };\n\n    var line = 1;\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            if (stat[name]) {\n                text = text.replace(repl[name], '$1');\n            } else {\n                // If we're toggling unordered-list formatting, check if the current line\n                // is part of an ordered-list, and if so, untoggle that first.\n                // Workaround for https://github.com/Ionaru/easy-markdown-editor/issues/92\n                if (name == 'unordered-list') {\n                    text = _toggle('ordered-list', text, true);\n                }\n                text = _toggle(name, text, false);\n                line += 1;\n            }\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n * @param {'link' | 'image'} type\n * @param {string} startEnd\n * @param {string} url\n */\nfunction _toggleLink(editor, type, startEnd, url) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var active = stat[type];\n    if (!active) {\n        _replaceSelection(cm, active, startEnd, url);\n        return;\n    }\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text = cm.getLine(startPoint.line);\n    var start = text.slice(0, startPoint.ch);\n    var end = text.slice(startPoint.ch);\n\n    if (type == 'link') {\n        start = start.replace(/(.*)[^!]\\[/, '$1');\n    } else if (type == 'image') {\n        start = start.replace(/(.*)!\\[$/, '$1');\n    }\n    end = end.replace(/]\\(.*?\\)/, '');\n\n    cm.replaceRange(start + end, {\n        line: startPoint.line,\n        ch: 0,\n    }, {\n        line: startPoint.line,\n        ch: 99999999999999,\n    });\n\n    startPoint.ch -= startEnd[0].length;\n    if (startPoint !== endPoint) {\n        endPoint.ch -= startEnd[0].length;\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n */\nfunction _toggleBlock(editor, type, start_chars, end_chars) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    end_chars = (typeof end_chars === 'undefined') ? start_chars : end_chars;\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n\n    var text;\n    var start = start_chars;\n    var end = end_chars;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n\n    if (stat[type]) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        if (type == 'bold') {\n            start = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, '');\n            end = end.replace(/(\\*\\*|__)/, '');\n        } else if (type == 'italic') {\n            start = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, '');\n            end = end.replace(/(\\*|_)/, '');\n        } else if (type == 'strikethrough') {\n            start = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, '');\n            end = end.replace(/(\\*\\*|~~)/, '');\n        }\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        }, {\n            line: startPoint.line,\n            ch: 99999999999999,\n        });\n\n        if (type == 'bold' || type == 'strikethrough') {\n            startPoint.ch -= 2;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 2;\n            }\n        } else if (type == 'italic') {\n            startPoint.ch -= 1;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 1;\n            }\n        }\n    } else {\n        text = cm.getSelection();\n        if (type == 'bold') {\n            text = text.split('**').join('');\n            text = text.split('__').join('');\n        } else if (type == 'italic') {\n            text = text.split('*').join('');\n            text = text.split('_').join('');\n        } else if (type == 'strikethrough') {\n            text = text.split('~~').join('');\n        }\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start_chars.length;\n        endPoint.ch = startPoint.ch + text.length;\n    }\n\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\nfunction _cleanBlock(cm) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text;\n\n    for (var line = startPoint.line; line <= endPoint.line; line++) {\n        text = cm.getLine(line);\n        text = text.replace(/^[ ]*([# ]+|\\*|-|[> ]+|[0-9]+(.|\\)))[ ]*/, '');\n\n        cm.replaceRange(text, {\n            line: line,\n            ch: 0,\n        }, {\n            line: line,\n            ch: 99999999999999,\n        });\n    }\n}\n\n/**\n * Convert a number of bytes to a human-readable file size. If you desire\n * to add a space between the value and the unit, you need to add this space\n * to the given units.\n * @param bytes {number} A number of bytes, as integer. Ex: 421137\n * @param units {number[]} An array of human-readable units, ie. [' B', ' K', ' MB']\n * @returns string A human-readable file size. Ex: '412 KB'\n */\nfunction humanFileSize(bytes, units) {\n    if (Math.abs(bytes) < 1024) {\n        return '' + bytes + units[0];\n    }\n    var u = 0;\n    do {\n        bytes /= 1024;\n        ++u;\n    } while (Math.abs(bytes) >= 1024 && u < units.length);\n    return '' + bytes.toFixed(1) + units[u];\n}\n\n// Merge the properties of one object into another.\nfunction _mergeProperties(target, source) {\n    for (var property in source) {\n        if (Object.prototype.hasOwnProperty.call(source, property)) {\n            if (source[property] instanceof Array) {\n                target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\n            } else if (\n                source[property] !== null &&\n                typeof source[property] === 'object' &&\n                source[property].constructor === Object\n            ) {\n                target[property] = _mergeProperties(target[property] || {}, source[property]);\n            } else {\n                target[property] = source[property];\n            }\n        }\n    }\n\n    return target;\n}\n\n// Merge an arbitrary number of objects into one.\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        target = _mergeProperties(target, arguments[i]);\n    }\n\n    return target;\n}\n\n/* The right word count in respect for CJK. */\nfunction wordCount(data) {\n    var pattern = /[a-zA-Z0-9_\\u00A0-\\u02AF\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\n    var m = data.match(pattern);\n    var count = 0;\n    if (m === null) return count;\n    for (var i = 0; i < m.length; i++) {\n        if (m[i].charCodeAt(0) >= 0x4E00) {\n            count += m[i].length;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nvar iconClassMap = {\n    'bold': 'fa fa-bold',\n    'italic': 'fa fa-italic',\n    'strikethrough': 'fa fa-strikethrough',\n    'heading': 'fa fa-header fa-heading',\n    'heading-smaller': 'fa fa-header fa-heading header-smaller',\n    'heading-bigger': 'fa fa-header fa-heading header-bigger',\n    'heading-1': 'fa fa-header fa-heading header-1',\n    'heading-2': 'fa fa-header fa-heading header-2',\n    'heading-3': 'fa fa-header fa-heading header-3',\n    'code': 'fa fa-code',\n    'quote': 'fa fa-quote-left',\n    'ordered-list': 'fa fa-list-ol',\n    'unordered-list': 'fa fa-list-ul',\n    'clean-block': 'fa fa-eraser',\n    'link': 'fa fa-link',\n    'image': 'fa fa-image',\n    'upload-image': 'fa fa-image',\n    'table': 'fa fa-table',\n    'horizontal-rule': 'fa fa-minus',\n    'preview': 'fa fa-eye',\n    'side-by-side': 'fa fa-columns',\n    'fullscreen': 'fa fa-arrows-alt',\n    'guide': 'fa fa-question-circle',\n    'undo': 'fa fa-undo',\n    'redo': 'fa fa-repeat fa-redo',\n};\n\nvar toolbarBuiltInButtons = {\n    'bold': {\n        name: 'bold',\n        action: toggleBold,\n        className: iconClassMap['bold'],\n        title: 'Bold',\n        default: true,\n    },\n    'italic': {\n        name: 'italic',\n        action: toggleItalic,\n        className: iconClassMap['italic'],\n        title: 'Italic',\n        default: true,\n    },\n    'strikethrough': {\n        name: 'strikethrough',\n        action: toggleStrikethrough,\n        className: iconClassMap['strikethrough'],\n        title: 'Strikethrough',\n    },\n    'heading': {\n        name: 'heading',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading'],\n        title: 'Heading',\n        default: true,\n    },\n    'heading-smaller': {\n        name: 'heading-smaller',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading-smaller'],\n        title: 'Smaller Heading',\n    },\n    'heading-bigger': {\n        name: 'heading-bigger',\n        action: toggleHeadingBigger,\n        className: iconClassMap['heading-bigger'],\n        title: 'Bigger Heading',\n    },\n    'heading-1': {\n        name: 'heading-1',\n        action: toggleHeading1,\n        className: iconClassMap['heading-1'],\n        title: 'Big Heading',\n    },\n    'heading-2': {\n        name: 'heading-2',\n        action: toggleHeading2,\n        className: iconClassMap['heading-2'],\n        title: 'Medium Heading',\n    },\n    'heading-3': {\n        name: 'heading-3',\n        action: toggleHeading3,\n        className: iconClassMap['heading-3'],\n        title: 'Small Heading',\n    },\n    'separator-1': {\n        name: 'separator-1',\n    },\n    'code': {\n        name: 'code',\n        action: toggleCodeBlock,\n        className: iconClassMap['code'],\n        title: 'Code',\n    },\n    'quote': {\n        name: 'quote',\n        action: toggleBlockquote,\n        className: iconClassMap['quote'],\n        title: 'Quote',\n        default: true,\n    },\n    'unordered-list': {\n        name: 'unordered-list',\n        action: toggleUnorderedList,\n        className: iconClassMap['unordered-list'],\n        title: 'Generic List',\n        default: true,\n    },\n    'ordered-list': {\n        name: 'ordered-list',\n        action: toggleOrderedList,\n        className: iconClassMap['ordered-list'],\n        title: 'Numbered List',\n        default: true,\n    },\n    'clean-block': {\n        name: 'clean-block',\n        action: cleanBlock,\n        className: iconClassMap['clean-block'],\n        title: 'Clean block',\n    },\n    'separator-2': {\n        name: 'separator-2',\n    },\n    'link': {\n        name: 'link',\n        action: drawLink,\n        className: iconClassMap['link'],\n        title: 'Create Link',\n        default: true,\n    },\n    'image': {\n        name: 'image',\n        action: drawImage,\n        className: iconClassMap['image'],\n        title: 'Insert Image',\n        default: true,\n    },\n    'upload-image': {\n        name: 'upload-image',\n        action: drawUploadedImage,\n        className: iconClassMap['upload-image'],\n        title: 'Import an image',\n    },\n    'table': {\n        name: 'table',\n        action: drawTable,\n        className: iconClassMap['table'],\n        title: 'Insert Table',\n    },\n    'horizontal-rule': {\n        name: 'horizontal-rule',\n        action: drawHorizontalRule,\n        className: iconClassMap['horizontal-rule'],\n        title: 'Insert Horizontal Line',\n    },\n    'separator-3': {\n        name: 'separator-3',\n    },\n    'preview': {\n        name: 'preview',\n        action: togglePreview,\n        className: iconClassMap['preview'],\n        noDisable: true,\n        title: 'Toggle Preview',\n        default: true,\n    },\n    'side-by-side': {\n        name: 'side-by-side',\n        action: toggleSideBySide,\n        className: iconClassMap['side-by-side'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Side by Side',\n        default: true,\n    },\n    'fullscreen': {\n        name: 'fullscreen',\n        action: toggleFullScreen,\n        className: iconClassMap['fullscreen'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Fullscreen',\n        default: true,\n    },\n    'separator-4': {\n        name: 'separator-4',\n    },\n    'guide': {\n        name: 'guide',\n        action: 'https://www.markdownguide.org/basic-syntax/',\n        className: iconClassMap['guide'],\n        noDisable: true,\n        title: 'Markdown Guide',\n        default: true,\n    },\n    'separator-5': {\n        name: 'separator-5',\n    },\n    'undo': {\n        name: 'undo',\n        action: undo,\n        className: iconClassMap['undo'],\n        noDisable: true,\n        title: 'Undo',\n    },\n    'redo': {\n        name: 'redo',\n        action: redo,\n        className: iconClassMap['redo'],\n        noDisable: true,\n        title: 'Redo',\n    },\n};\n\nvar insertTexts = {\n    link: ['[', '](#url#)'],\n    image: ['![', '](#url#)'],\n    uploadedImage: ['![](#url#)', ''],\n    // uploadedImage: ['![](#url#)\\n', ''], // TODO: New line insertion doesn't work here.\n    table: ['', '\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n'],\n    horizontalRule: ['', '\\n\\n-----\\n\\n'],\n};\n\nvar promptTexts = {\n    link: 'URL for the link:',\n    image: 'URL of the image:',\n};\n\nvar timeFormat = {\n    locale: 'en-US',\n    format: {\n        hour: '2-digit',\n        minute: '2-digit',\n    },\n};\n\nvar blockStyles = {\n    'bold': '**',\n    'code': '```',\n    'italic': '*',\n};\n\n/**\n * Texts displayed to the user (mainly on the status bar) for the import image\n * feature. Can be used for customization or internationalization.\n */\nvar imageTexts = {\n    sbInit: 'Attach files by drag and dropping or pasting from clipboard.',\n    sbOnDragEnter: 'Drop image to upload it.',\n    sbOnDrop: 'Uploading image #images_names#...',\n    sbProgress: 'Uploading #file_name#: #progress#%',\n    sbOnUploaded: 'Uploaded #image_name#',\n    sizeUnits: ' B, KB, MB',\n};\n\n/**\n * Errors displayed to the user, using the `errorCallback` option. Can be used for\n * customization or internationalization.\n */\nvar errorMessages = {\n    noFileGiven: 'You must select a file.',\n    typeNotAllowed: 'This image type is not allowed.',\n    fileTooLarge: 'Image #image_name# is too big (#image_size#).\\n' +\n        'Maximum file size is #image_max_size#.',\n    importError: 'Something went wrong when uploading the image #image_name#.',\n};\n\n/**\n * Interface of EasyMDE.\n */\nfunction EasyMDE(options) {\n    // Handle options parameter\n    options = options || {};\n\n    // Used later to refer to it\"s parent\n    options.parent = this;\n\n    // Check if Font Awesome needs to be auto downloaded\n    var autoDownloadFA = true;\n\n    if (options.autoDownloadFontAwesome === false) {\n        autoDownloadFA = false;\n    }\n\n    if (options.autoDownloadFontAwesome !== true) {\n        var styleSheets = document.styleSheets;\n        for (var i = 0; i < styleSheets.length; i++) {\n            if (!styleSheets[i].href)\n                continue;\n\n            if (styleSheets[i].href.indexOf('//maxcdn.bootstrapcdn.com/font-awesome/') > -1) {\n                autoDownloadFA = false;\n            }\n        }\n    }\n\n    if (autoDownloadFA) {\n        var link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css';\n        document.getElementsByTagName('head')[0].appendChild(link);\n    }\n\n\n    // Find the textarea to use\n    if (options.element) {\n        this.element = options.element;\n    } else if (options.element === null) {\n        // This means that the element option was specified, but no element was found\n        console.log('EasyMDE: Error. No element was found.');\n        return;\n    }\n\n\n    // Handle toolbar\n    if (options.toolbar === undefined) {\n        // Initialize\n        options.toolbar = [];\n\n\n        // Loop over the built in buttons, to get the preferred order\n        for (var key in toolbarBuiltInButtons) {\n            if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {\n                if (key.indexOf('separator-') != -1) {\n                    options.toolbar.push('|');\n                }\n\n                if (toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {\n                    options.toolbar.push(key);\n                }\n            }\n        }\n    }\n\n    // Editor preview styling class.\n    if (!Object.prototype.hasOwnProperty.call(options, 'previewClass')) {\n        options.previewClass = 'editor-preview';\n    }\n\n    // Handle status bar\n    if (!Object.prototype.hasOwnProperty.call(options, 'status')) {\n        options.status = ['autosave', 'lines', 'words', 'cursor'];\n\n        if (options.uploadImage) {\n            options.status.unshift('upload-image');\n        }\n    }\n\n\n    // Add default preview rendering function\n    if (!options.previewRender) {\n        options.previewRender = function (plainText) {\n            // Note: \"this\" refers to the options object\n            return this.parent.markdown(plainText);\n        };\n    }\n\n\n    // Set default options for parsing config\n    options.parsingConfig = extend({\n        highlightFormatting: true, // needed for toggleCodeBlock to detect types of code\n    }, options.parsingConfig || {});\n\n\n    // Merging the insertTexts, with the given options\n    options.insertTexts = extend({}, insertTexts, options.insertTexts || {});\n\n\n    // Merging the promptTexts, with the given options\n    options.promptTexts = extend({}, promptTexts, options.promptTexts || {});\n\n\n    // Merging the blockStyles, with the given options\n    options.blockStyles = extend({}, blockStyles, options.blockStyles || {});\n\n\n    if (options.autosave != undefined) {\n        // Merging the Autosave timeFormat, with the given options\n        options.autosave.timeFormat = extend({}, timeFormat, options.autosave.timeFormat || {});\n    }\n\n    options.iconClassMap = extend({}, iconClassMap, options.iconClassMap || {});\n\n    // Merging the shortcuts, with the given options\n    options.shortcuts = extend({}, shortcuts, options.shortcuts || {});\n\n    options.maxHeight = options.maxHeight || undefined;\n\n    options.direction = options.direction || 'ltr';\n\n    if (typeof options.maxHeight !== 'undefined') {\n        // Min and max height are equal if maxHeight is set\n        options.minHeight = options.maxHeight;\n    } else {\n        options.minHeight = options.minHeight || '300px';\n    }\n\n    options.errorCallback = options.errorCallback || function (errorMessage) {\n        alert(errorMessage);\n    };\n\n    // Import-image default configuration\n    options.uploadImage = options.uploadImage || false;\n    options.imageMaxSize = options.imageMaxSize || 2097152; // 1024 * 1024 * 2\n    options.imageAccept = options.imageAccept || 'image/png, image/jpeg, image/gif, image/avif';\n    options.imageTexts = extend({}, imageTexts, options.imageTexts || {});\n    options.errorMessages = extend({}, errorMessages, options.errorMessages || {});\n    options.imagePathAbsolute = options.imagePathAbsolute || false;\n    options.imageCSRFName = options.imageCSRFName || 'csrfmiddlewaretoken';\n    options.imageCSRFHeader = options.imageCSRFHeader || false;\n\n\n    // Change unique_id to uniqueId for backwards compatibility\n    if (options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != '')\n        options.autosave.uniqueId = options.autosave.unique_id;\n\n    // If overlay mode is specified and combine is not provided, default it to true\n    if (options.overlayMode && options.overlayMode.combine === undefined) {\n        options.overlayMode.combine = true;\n    }\n\n    // Update this options\n    this.options = options;\n\n\n    // Auto render\n    this.render();\n\n\n    // The codemirror component is only available after rendering\n    // so, the setter for the initialValue can only run after\n    // the element has been rendered\n    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\n        this.value(options.initialValue);\n    }\n\n    if (options.uploadImage) {\n        var self = this;\n\n        this.codemirror.on('dragenter', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragend', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragleave', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('dragover', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('drop', function (cm, event) {\n            event.stopPropagation();\n            event.preventDefault();\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);\n            } else {\n                self.uploadImages(event.dataTransfer.files);\n            }\n        });\n\n        this.codemirror.on('paste', function (cm, event) {\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);\n            } else {\n                self.uploadImages(event.clipboardData.files);\n            }\n        });\n    }\n}\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param {FileList} files The files to upload the the server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.uploadImages = function (files, onSuccess, onError) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImage(files[i], onSuccess, onError);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options.\n * @param {FileList} files The files to upload the the server.\n */\nEasyMDE.prototype.uploadImagesUsingCustomFunction = function (imageUploadFunction, files) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Update an item in the status bar.\n * @param itemName {string} The name of the item to update (ie. 'upload-image', 'autosave', etc.).\n * @param content {string} the new content of the item to write in the status bar.\n */\nEasyMDE.prototype.updateStatusBar = function (itemName, content) {\n    if (!this.gui.statusbar) {\n        return;\n    }\n\n    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);\n    if (matchingClasses.length === 1) {\n        this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;\n    } else if (matchingClasses.length === 0) {\n        console.log('EasyMDE: status bar item ' + itemName + ' was not found.');\n    } else {\n        console.log('EasyMDE: Several status bar items named ' + itemName + ' was found.');\n    }\n};\n\n/**\n * Default markdown render.\n */\nEasyMDE.prototype.markdown = function (text) {\n    if (marked) {\n        // Initialize\n        var markedOptions;\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {\n            markedOptions = this.options.renderingConfig.markedOptions;\n        } else {\n            markedOptions = {};\n        }\n\n        // Update options\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\n            markedOptions.breaks = false;\n        } else {\n            markedOptions.breaks = true;\n        }\n\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {\n\n            /* Get HLJS from config or window */\n            var hljs = this.options.renderingConfig.hljs || window.hljs;\n\n            /* Check if HLJS loaded */\n            if (hljs) {\n                markedOptions.highlight = function (code, language) {\n                    if (language && hljs.getLanguage(language)) {\n                        return hljs.highlight(language, code).value;\n                    } else {\n                        return hljs.highlightAuto(code).value;\n                    }\n                };\n            }\n        }\n\n        // Set options\n        marked.setOptions(markedOptions);\n\n        // Convert the markdown to HTML\n        var htmlText = marked.parse(text);\n\n        // Sanitize HTML\n        if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === 'function') {\n            htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);\n        }\n\n        // Edit the HTML anchors to add 'target=\"_blank\"' by default.\n        htmlText = addAnchorTargetBlank(htmlText);\n\n        // Remove list-style when rendering checkboxes\n        htmlText = removeListStyleWhenCheckbox(htmlText);\n\n        return htmlText;\n    }\n};\n\n/**\n * Render editor to the given element.\n */\nEasyMDE.prototype.render = function (el) {\n    if (!el) {\n        el = this.element || document.getElementsByTagName('textarea')[0];\n    }\n\n    if (this._rendered && this._rendered === el) {\n        // Already rendered.\n        return;\n    }\n\n    this.element = el;\n    var options = this.options;\n\n    var self = this;\n    var keyMaps = {};\n\n    for (var key in options.shortcuts) {\n        // null stands for \"do not bind this command\"\n        if (options.shortcuts[key] !== null && bindings[key] !== null) {\n            (function (key) {\n                keyMaps[fixShortcut(options.shortcuts[key])] = function () {\n                    var action = bindings[key];\n                    if (typeof action === 'function') {\n                        action(self);\n                    } else if (typeof action === 'string') {\n                        window.open(action, '_blank');\n                    }\n                };\n            })(key);\n        }\n    }\n\n    keyMaps['Enter'] = 'newlineAndIndentContinueMarkdownList';\n    keyMaps['Tab'] = 'tabAndIndentMarkdownList';\n    keyMaps['Shift-Tab'] = 'shiftTabAndUnindentMarkdownList';\n    keyMaps['Esc'] = function (cm) {\n        if (cm.getOption('fullScreen')) toggleFullScreen(self);\n    };\n\n    this.documentOnKeyDown = function (e) {\n        e = e || window.event;\n\n        if (e.keyCode == 27) {\n            if (self.codemirror.getOption('fullScreen')) toggleFullScreen(self);\n        }\n    };\n    document.addEventListener('keydown', this.documentOnKeyDown, false);\n\n    var mode, backdrop;\n\n    // CodeMirror overlay mode\n    if (options.overlayMode) {\n        CodeMirror.defineMode('overlay-mode', function (config) {\n            return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? 'spell-checker' : 'gfm'), options.overlayMode.mode, options.overlayMode.combine);\n        });\n\n        mode = 'overlay-mode';\n        backdrop = options.parsingConfig;\n        backdrop.gitHubSpice = false;\n    } else {\n        mode = options.parsingConfig;\n        mode.name = 'gfm';\n        mode.gitHubSpice = false;\n    }\n    if (options.spellChecker !== false) {\n        mode = 'spell-checker';\n        backdrop = options.parsingConfig;\n        backdrop.name = 'gfm';\n        backdrop.gitHubSpice = false;\n\n        if (typeof options.spellChecker === 'function') {\n            options.spellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        } else {\n            CodeMirrorSpellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        }\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    function configureMouse(cm, repeat, event) {\n        return {\n            addNew: false,\n        };\n    }\n\n    this.codemirror = CodeMirror.fromTextArea(el, {\n        mode: mode,\n        backdrop: backdrop,\n        theme: (options.theme != undefined) ? options.theme : 'easymde',\n        tabSize: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentWithTabs: (options.indentWithTabs === false) ? false : true,\n        lineNumbers: (options.lineNumbers === true) ? true : false,\n        autofocus: (options.autofocus === true) ? true : false,\n        extraKeys: keyMaps,\n        direction: options.direction,\n        lineWrapping: (options.lineWrapping === false) ? false : true,\n        allowDropFileTypes: ['text/plain'],\n        placeholder: options.placeholder || el.getAttribute('placeholder') || '',\n        styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : !isMobile(),\n        scrollbarStyle: (options.scrollbarStyle != undefined) ? options.scrollbarStyle : 'native',\n        configureMouse: configureMouse,\n        inputStyle: (options.inputStyle != undefined) ? options.inputStyle : isMobile() ? 'contenteditable' : 'textarea',\n        spellcheck: (options.nativeSpellcheck != undefined) ? options.nativeSpellcheck : true,\n        autoRefresh: (options.autoRefresh != undefined) ? options.autoRefresh : false,\n    });\n\n    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;\n\n    if (typeof options.maxHeight !== 'undefined') {\n        this.codemirror.getScrollerElement().style.height = options.maxHeight;\n    }\n\n    if (options.forceSync === true) {\n        var cm = this.codemirror;\n        cm.on('change', function () {\n            cm.save();\n        });\n    }\n\n    this.gui = {};\n\n    // Wrap Codemirror with container before create toolbar, etc,\n    // to use with sideBySideFullscreen option.\n    var easyMDEContainer = document.createElement('div');\n    easyMDEContainer.classList.add('EasyMDEContainer');\n    easyMDEContainer.setAttribute('role', 'application');\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);\n    easyMDEContainer.appendChild(cmWrapper);\n\n    if (options.toolbar !== false) {\n        this.gui.toolbar = this.createToolbar();\n    }\n    if (options.status !== false) {\n        this.gui.statusbar = this.createStatusbar();\n    }\n    if (options.autosave != undefined && options.autosave.enabled === true) {\n        this.autosave(); // use to load localstorage content\n        this.codemirror.on('change', function () {\n            clearTimeout(self._autosave_timeout);\n            self._autosave_timeout = setTimeout(function () {\n                self.autosave();\n            }, self.options.autosave.submit_delay || self.options.autosave.delay || 1000);\n        });\n    }\n\n    function calcHeight(naturalWidth, naturalHeight) {\n        var height;\n        var viewportWidth = window.getComputedStyle(document.querySelector('.CodeMirror-sizer')).width.replace('px', '');\n        if (naturalWidth < viewportWidth) {\n            height = naturalHeight + 'px';\n        } else {\n            height = (naturalHeight / naturalWidth * 100) + '%';\n        }\n        return height;\n    }\n\n    var _vm = this;\n\n\n    function assignImageBlockAttributes(parentEl, img) {\n        parentEl.setAttribute('data-img-src', img.url);\n        parentEl.setAttribute('style', '--bg-image:url(' + img.url + ');--width:' + img.naturalWidth + 'px;--height:' + calcHeight(img.naturalWidth, img.naturalHeight));\n        _vm.codemirror.setSize();\n    }\n\n    function handleImages() {\n        if (!options.previewImagesInEditor) {\n            return;\n        }\n\n        easyMDEContainer.querySelectorAll('.cm-image-marker').forEach(function (e) {\n            var parentEl = e.parentElement;\n            if (!parentEl.innerText.match(/^!\\[.*?\\]\\(.*\\)/g)) {\n                // if img pasted on the same line with other text, don't preview, preview only images on separate line\n                return;\n            }\n            if (!parentEl.hasAttribute('data-img-src')) {\n                var srcAttr = parentEl.innerText.match('\\\\((.*)\\\\)'); // might require better parsing according to markdown spec\n                if (!window.EMDEimagesCache) {\n                    window.EMDEimagesCache = {};\n                }\n\n                if (srcAttr && srcAttr.length >= 2) {\n                    var keySrc = srcAttr[1];\n\n                    if (options.imagesPreviewHandler) {\n                        var newSrc = options.imagesPreviewHandler(srcAttr[1]);\n                        // defensive check making sure the handler provided by the user returns a string\n                        if (typeof newSrc === 'string') {\n                            keySrc = newSrc;\n                        }\n                    }\n\n                    if (!window.EMDEimagesCache[keySrc]) {\n                        var img = document.createElement('img');\n                        img.onload = function () {\n                            window.EMDEimagesCache[keySrc] = {\n                                naturalWidth: img.naturalWidth,\n                                naturalHeight: img.naturalHeight,\n                                url: keySrc,\n                            };\n                            assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                        };\n                        img.src = keySrc;\n                    } else {\n                        assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                    }\n                }\n            }\n        });\n    }\n\n    this.codemirror.on('update', function () {\n        handleImages();\n    });\n\n    this.gui.sideBySide = this.createSideBySide();\n    this._rendered = this.element;\n\n    if (options.autofocus === true || el.autofocus) {\n        this.codemirror.focus();\n    }\n\n    // Fixes CodeMirror bug (#344)\n    var temp_cm = this.codemirror;\n    setTimeout(function () {\n        temp_cm.refresh();\n    }.bind(temp_cm), 0);\n};\n\nEasyMDE.prototype.cleanup = function () {\n    document.removeEventListener('keydown', this.documentOnKeyDown);\n};\n\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\nfunction isLocalStorageAvailable() {\n    if (typeof localStorage === 'object') {\n        try {\n            localStorage.setItem('smde_localStorage', 1);\n            localStorage.removeItem('smde_localStorage');\n        } catch (e) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n}\n\nEasyMDE.prototype.autosave = function () {\n    if (isLocalStorageAvailable()) {\n        var easyMDE = this;\n\n        if (this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to use the autosave feature');\n            return;\n        }\n\n        if (this.options.autosave.binded !== true) {\n            if (easyMDE.element.form != null && easyMDE.element.form != undefined) {\n                easyMDE.element.form.addEventListener('submit', function () {\n                    clearTimeout(easyMDE.autosaveTimeoutId);\n                    easyMDE.autosaveTimeoutId = undefined;\n\n                    localStorage.removeItem('smde_' + easyMDE.options.autosave.uniqueId);\n                });\n            }\n\n            this.options.autosave.binded = true;\n        }\n\n        if (this.options.autosave.loaded !== true) {\n            if (typeof localStorage.getItem('smde_' + this.options.autosave.uniqueId) == 'string' && localStorage.getItem('smde_' + this.options.autosave.uniqueId) != '') {\n                this.codemirror.setValue(localStorage.getItem('smde_' + this.options.autosave.uniqueId));\n                this.options.autosave.foundSavedValue = true;\n            }\n\n            this.options.autosave.loaded = true;\n        }\n\n        var value = easyMDE.value();\n        if (value !== '') {\n            localStorage.setItem('smde_' + this.options.autosave.uniqueId, value);\n        } else {\n            localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n        }\n\n        var el = document.getElementById('autosaved');\n        if (el != null && el != undefined && el != '') {\n            var d = new Date();\n            var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, 'en-US'], this.options.autosave.timeFormat.format).format(d);\n            var save = this.options.autosave.text == undefined ? 'Autosaved: ' : this.options.autosave.text;\n\n            el.innerHTML = save + dd;\n        }\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\nEasyMDE.prototype.clearAutosavedValue = function () {\n    if (isLocalStorageAvailable()) {\n        if (this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to clear the autosave value');\n            return;\n        }\n\n        localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\n/**\n * Open the browse-file window to upload an image to a server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.openBrowseFileWindow = function (onSuccess, onError) {\n    var self = this;\n    var imageInput = this.gui.toolbar.getElementsByClassName('imageInput')[0];\n    imageInput.click(); //dispatchEvent(new MouseEvent('click'));  // replaced with click() for IE11 compatibility.\n    function onChange(event) {\n        if (self.options.imageUploadFunction) {\n            self.uploadImagesUsingCustomFunction(self.options.imageUploadFunction, event.target.files);\n        } else {\n            self.uploadImages(event.target.files, onSuccess, onError);\n        }\n        imageInput.removeEventListener('change', onChange);\n    }\n\n    imageInput.addEventListener('change', onChange);\n};\n\n/**\n * Upload an image to the server.\n *\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File)\n * @param [onSuccess] {function} A callback function to execute after the image has been successfully uploaded, with one parameter:\n * - url (string): The URL of the uploaded image.\n * @param [onError] {function} A callback function to execute when the image upload fails, with one parameter:\n * - error (string): the detailed error to display to the user (based on messages from options.errorMessages).\n */\nEasyMDE.prototype.uploadImage = function (file, onSuccess, onError) {\n    var self = this;\n    onSuccess = onSuccess || function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    };\n\n    function onErrorSup(errorMessage) {\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', errorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run custom error handler\n        if (onError && typeof onError === 'function') {\n            onError(errorMessage);\n        }\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(errorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    if (file.size > this.options.imageMaxSize) {\n        onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));\n        return;\n    }\n\n    var formData = new FormData();\n    formData.append('image', file);\n\n    // insert CSRF body token if provided in config.\n    if (self.options.imageCSRFToken && !self.options.imageCSRFHeader) {\n        formData.append(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    var request = new XMLHttpRequest();\n    request.upload.onprogress = function (event) {\n        if (event.lengthComputable) {\n            var progress = '' + Math.round((event.loaded * 100) / event.total);\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbProgress.replace('#file_name#', file.name).replace('#progress#', progress));\n        }\n    };\n    request.open('POST', this.options.imageUploadEndpoint);\n\n    // insert CSRF header token if provided in config.\n    if (self.options.imageCSRFToken && self.options.imageCSRFHeader) {\n        request.setRequestHeader(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    request.onload = function () {\n        try {\n            var response = JSON.parse(this.responseText);\n        } catch (error) {\n            console.error('EasyMDE: The server did not return a valid json.');\n            onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            return;\n        }\n        if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {\n            onSuccess((self.options.imagePathAbsolute ? '' : (window.location.origin + '/')) + response.data.filePath);\n        } else {\n            if (response.error && response.error in self.options.errorMessages) {  // preformatted error message\n                onErrorSup(fillErrorMessage(self.options.errorMessages[response.error]));\n            } else if (response.error) {  // server side generated error message\n                onErrorSup(fillErrorMessage(response.error));\n            } else {  //unknown error\n                console.error('EasyMDE: Received an unexpected response after uploading the image.'\n                    + this.status + ' (' + this.statusText + ')');\n                onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            }\n        }\n    };\n\n    request.onerror = function (event) {\n        console.error('EasyMDE: An unexpected error occurred when trying to upload the image.'\n            + event.target.status + ' (' + event.target.statusText + ')');\n        onErrorSup(self.options.errorMessages.importError);\n    };\n\n    request.send(formData);\n\n};\n\n/**\n * Upload an image to the server using a custom upload function.\n *\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File).\n */\nEasyMDE.prototype.uploadImageUsingCustomFunction = function (imageUploadFunction, file) {\n    var self = this;\n\n    function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    }\n\n    function onError(errorMessage) {\n        var filledErrorMessage = fillErrorMessage(errorMessage);\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', filledErrorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(filledErrorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    imageUploadFunction.apply(this, [file, onSuccess, onError]);\n};\n\nEasyMDE.prototype.setPreviewMaxHeight = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    // Calc preview max height\n    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);\n    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);\n    var optionsMaxHeight = parseInt(this.options.maxHeight);\n    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;\n    var previewMaxHeight = wrapperMaxHeight.toString() + 'px';\n\n    preview.style.height = previewMaxHeight;\n};\n\nEasyMDE.prototype.createSideBySide = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    if (!preview || !preview.classList.contains('editor-preview-side')) {\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-side';\n\n        if (this.options.previewClass) {\n\n            if (Array.isArray(this.options.previewClass)) {\n                for (var i = 0; i < this.options.previewClass.length; i++) {\n                    preview.classList.add(this.options.previewClass[i]);\n                }\n\n            } else if (typeof this.options.previewClass === 'string') {\n                preview.classList.add(this.options.previewClass);\n            }\n        }\n\n        wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\n    }\n\n    if (typeof this.options.maxHeight !== 'undefined') {\n        this.setPreviewMaxHeight();\n    }\n\n    if (this.options.syncSideBySidePreviewScroll === false) return preview;\n    // Syncs scroll  editor -> preview\n    var cScroll = false;\n    var pScroll = false;\n    cm.on('scroll', function (v) {\n        if (cScroll) {\n            cScroll = false;\n            return;\n        }\n        pScroll = true;\n        var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\n        var ratio = parseFloat(v.getScrollInfo().top) / height;\n        var move = (preview.scrollHeight - preview.clientHeight) * ratio;\n        preview.scrollTop = move;\n    });\n\n    // Syncs scroll  preview -> editor\n    preview.onscroll = function () {\n        if (pScroll) {\n            pScroll = false;\n            return;\n        }\n        cScroll = true;\n        var height = preview.scrollHeight - preview.clientHeight;\n        var ratio = parseFloat(preview.scrollTop) / height;\n        var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\n        cm.scrollTo(0, move);\n    };\n    return preview;\n};\n\nEasyMDE.prototype.createToolbar = function (items) {\n    items = items || this.options.toolbar;\n\n    if (!items || items.length === 0) {\n        return;\n    }\n    var i;\n    for (i = 0; i < items.length; i++) {\n        if (toolbarBuiltInButtons[items[i]] != undefined) {\n            items[i] = toolbarBuiltInButtons[items[i]];\n        }\n    }\n\n    var bar = document.createElement('div');\n    bar.className = 'editor-toolbar';\n    bar.setAttribute('role', 'toolbar');\n\n    var self = this;\n\n    var toolbarData = {};\n    self.toolbar = items;\n\n    for (i = 0; i < items.length; i++) {\n        if (items[i].name == 'guide' && self.options.toolbarGuideIcon === false)\n            continue;\n\n        if (self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)\n            continue;\n\n        // Fullscreen does not work well on mobile devices (even tablets)\n        // In the future, hopefully this can be resolved\n        if ((items[i].name == 'fullscreen' || items[i].name == 'side-by-side') && isMobile())\n            continue;\n\n\n        // Don't include trailing separators\n        if (items[i] === '|') {\n            var nonSeparatorIconsFollow = false;\n\n            for (var x = (i + 1); x < items.length; x++) {\n                if (items[x] !== '|' && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\n                    nonSeparatorIconsFollow = true;\n                }\n            }\n\n            if (!nonSeparatorIconsFollow)\n                continue;\n        }\n\n\n        // Create the icon and append to the toolbar\n        (function (item) {\n            var el;\n            if (item === '|') {\n                el = createSep();\n            } else if (item.children) {\n                el = createToolbarDropdown(item, self.options.toolbarTips, self.options.shortcuts, self);\n            } else {\n                el = createToolbarButton(item, true, self.options.toolbarTips, self.options.shortcuts, 'button', self);\n            }\n\n\n            toolbarData[item.name || item] = el;\n            bar.appendChild(el);\n\n            // Create the input element (ie. <input type='file'>), used among\n            // with the 'import-image' icon to open the browse-file window.\n            if (item.name === 'upload-image') {\n                var imageInput = document.createElement('input');\n                imageInput.className = 'imageInput';\n                imageInput.type = 'file';\n                imageInput.multiple = true;\n                imageInput.name = 'image';\n                imageInput.accept = self.options.imageAccept;\n                imageInput.style.display = 'none';\n                imageInput.style.opacity = 0;\n                bar.appendChild(imageInput);\n            }\n        })(items[i]);\n    }\n\n    self.toolbar_div = bar;\n    self.toolbarElements = toolbarData;\n\n    var cm = this.codemirror;\n    cm.on('cursorActivity', function () {\n        var stat = getState(cm);\n\n        for (var key in toolbarData) {\n            (function (key) {\n                var el = toolbarData[key];\n                if (stat[key]) {\n                    el.classList.add('active');\n                } else if (key != 'fullscreen' && key != 'side-by-side') {\n                    el.classList.remove('active');\n                }\n            })(key);\n        }\n    });\n\n    var cmWrapper = cm.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper);\n    return bar;\n};\n\nEasyMDE.prototype.createStatusbar = function (status) {\n    // Initialize\n    status = status || this.options.status;\n    var options = this.options;\n    var cm = this.codemirror;\n\n    // Make sure the status variable is valid\n    if (!status || status.length === 0) {\n        return;\n    }\n\n    // Set up the built-in items\n    var items = [];\n    var i, onUpdate, onActivity, defaultValue;\n\n    for (i = 0; i < status.length; i++) {\n        // Reset some values\n        onUpdate = undefined;\n        onActivity = undefined;\n        defaultValue = undefined;\n\n\n        // Handle if custom or not\n        if (typeof status[i] === 'object') {\n            items.push({\n                className: status[i].className,\n                defaultValue: status[i].defaultValue,\n                onUpdate: status[i].onUpdate,\n                onActivity: status[i].onActivity,\n            });\n        } else {\n            var name = status[i];\n\n            if (name === 'words') {\n                defaultValue = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n            } else if (name === 'lines') {\n                defaultValue = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n            } else if (name === 'cursor') {\n                defaultValue = function (el) {\n                    el.innerHTML = '1:1';\n                };\n                onActivity = function (el) {\n                    var pos = cm.getCursor();\n                    var posLine = pos.line + 1;\n                    var posColumn = pos.ch + 1;\n                    el.innerHTML = posLine + ':' + posColumn;\n                };\n            } else if (name === 'autosave') {\n                defaultValue = function (el) {\n                    if (options.autosave != undefined && options.autosave.enabled === true) {\n                        el.setAttribute('id', 'autosaved');\n                    }\n                };\n            } else if (name === 'upload-image') {\n                defaultValue = function (el) {\n                    el.innerHTML = options.imageTexts.sbInit;\n                };\n            }\n\n            items.push({\n                className: name,\n                defaultValue: defaultValue,\n                onUpdate: onUpdate,\n                onActivity: onActivity,\n            });\n        }\n    }\n\n\n    // Create element for the status bar\n    var bar = document.createElement('div');\n    bar.className = 'editor-statusbar';\n\n\n    // Create a new span for each item\n    for (i = 0; i < items.length; i++) {\n        // Store in temporary variable\n        var item = items[i];\n\n\n        // Create span element\n        var el = document.createElement('span');\n        el.className = item.className;\n\n\n        // Ensure the defaultValue is a function\n        if (typeof item.defaultValue === 'function') {\n            item.defaultValue(el);\n        }\n\n\n        // Ensure the onUpdate is a function\n        if (typeof item.onUpdate === 'function') {\n            // Create a closure around the span of the current action, then execute the onUpdate handler\n            this.codemirror.on('update', (function (el, item) {\n                return function () {\n                    item.onUpdate(el);\n                };\n            }(el, item)));\n        }\n        if (typeof item.onActivity === 'function') {\n            // Create a closure around the span of the current action, then execute the onActivity handler\n            this.codemirror.on('cursorActivity', (function (el, item) {\n                return function () {\n                    item.onActivity(el);\n                };\n            }(el, item)));\n        }\n\n\n        // Append the item to the status bar\n        bar.appendChild(el);\n    }\n\n\n    // Insert the status bar into the DOM\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\n    return bar;\n};\n\n/**\n * Get or set the text content.\n */\nEasyMDE.prototype.value = function (val) {\n    var cm = this.codemirror;\n    if (val === undefined) {\n        return cm.getValue();\n    } else {\n        cm.getDoc().setValue(val);\n        if (this.isPreviewActive()) {\n            var wrapper = cm.getWrapperElement();\n            var preview = wrapper.lastChild;\n            var preview_result = this.options.previewRender(val, preview);\n            if (preview_result !== null) {\n                preview.innerHTML = preview_result;\n            }\n\n        }\n        return this;\n    }\n};\n\n\n/**\n * Bind static methods for exports.\n */\nEasyMDE.toggleBold = toggleBold;\nEasyMDE.toggleItalic = toggleItalic;\nEasyMDE.toggleStrikethrough = toggleStrikethrough;\nEasyMDE.toggleBlockquote = toggleBlockquote;\nEasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;\nEasyMDE.toggleHeadingBigger = toggleHeadingBigger;\nEasyMDE.toggleHeading1 = toggleHeading1;\nEasyMDE.toggleHeading2 = toggleHeading2;\nEasyMDE.toggleHeading3 = toggleHeading3;\nEasyMDE.toggleHeading4 = toggleHeading4;\nEasyMDE.toggleHeading5 = toggleHeading5;\nEasyMDE.toggleHeading6 = toggleHeading6;\nEasyMDE.toggleCodeBlock = toggleCodeBlock;\nEasyMDE.toggleUnorderedList = toggleUnorderedList;\nEasyMDE.toggleOrderedList = toggleOrderedList;\nEasyMDE.cleanBlock = cleanBlock;\nEasyMDE.drawLink = drawLink;\nEasyMDE.drawImage = drawImage;\nEasyMDE.drawUploadedImage = drawUploadedImage;\nEasyMDE.drawTable = drawTable;\nEasyMDE.drawHorizontalRule = drawHorizontalRule;\nEasyMDE.undo = undo;\nEasyMDE.redo = redo;\nEasyMDE.togglePreview = togglePreview;\nEasyMDE.toggleSideBySide = toggleSideBySide;\nEasyMDE.toggleFullScreen = toggleFullScreen;\n\n/**\n * Bind instance methods for exports.\n */\nEasyMDE.prototype.toggleBold = function () {\n    toggleBold(this);\n};\nEasyMDE.prototype.toggleItalic = function () {\n    toggleItalic(this);\n};\nEasyMDE.prototype.toggleStrikethrough = function () {\n    toggleStrikethrough(this);\n};\nEasyMDE.prototype.toggleBlockquote = function () {\n    toggleBlockquote(this);\n};\nEasyMDE.prototype.toggleHeadingSmaller = function () {\n    toggleHeadingSmaller(this);\n};\nEasyMDE.prototype.toggleHeadingBigger = function () {\n    toggleHeadingBigger(this);\n};\nEasyMDE.prototype.toggleHeading1 = function () {\n    toggleHeading1(this);\n};\nEasyMDE.prototype.toggleHeading2 = function () {\n    toggleHeading2(this);\n};\nEasyMDE.prototype.toggleHeading3 = function () {\n    toggleHeading3(this);\n};\nEasyMDE.prototype.toggleHeading4 = function () {\n    toggleHeading4(this);\n};\nEasyMDE.prototype.toggleHeading5 = function () {\n    toggleHeading5(this);\n};\nEasyMDE.prototype.toggleHeading6 = function () {\n    toggleHeading6(this);\n};\nEasyMDE.prototype.toggleCodeBlock = function () {\n    toggleCodeBlock(this);\n};\nEasyMDE.prototype.toggleUnorderedList = function () {\n    toggleUnorderedList(this);\n};\nEasyMDE.prototype.toggleOrderedList = function () {\n    toggleOrderedList(this);\n};\nEasyMDE.prototype.cleanBlock = function () {\n    cleanBlock(this);\n};\nEasyMDE.prototype.drawLink = function () {\n    drawLink(this);\n};\nEasyMDE.prototype.drawImage = function () {\n    drawImage(this);\n};\nEasyMDE.prototype.drawUploadedImage = function () {\n    drawUploadedImage(this);\n};\nEasyMDE.prototype.drawTable = function () {\n    drawTable(this);\n};\nEasyMDE.prototype.drawHorizontalRule = function () {\n    drawHorizontalRule(this);\n};\nEasyMDE.prototype.undo = function () {\n    undo(this);\n};\nEasyMDE.prototype.redo = function () {\n    redo(this);\n};\nEasyMDE.prototype.togglePreview = function () {\n    togglePreview(this);\n};\nEasyMDE.prototype.toggleSideBySide = function () {\n    toggleSideBySide(this);\n};\nEasyMDE.prototype.toggleFullScreen = function () {\n    toggleFullScreen(this);\n};\n\nEasyMDE.prototype.isPreviewActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.lastChild;\n\n    return preview.classList.contains('editor-preview-active');\n};\n\nEasyMDE.prototype.isSideBySideActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    return preview.classList.contains('editor-preview-active-side');\n};\n\nEasyMDE.prototype.isFullscreenActive = function () {\n    var cm = this.codemirror;\n\n    return cm.getOption('fullScreen');\n};\n\nEasyMDE.prototype.getState = function () {\n    var cm = this.codemirror;\n\n    return getState(cm);\n};\n\nEasyMDE.prototype.toTextArea = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (easyMDEContainer) {\n        if (this.gui.toolbar) {\n            easyMDEContainer.removeChild(this.gui.toolbar);\n        }\n        if (this.gui.statusbar) {\n            easyMDEContainer.removeChild(this.gui.statusbar);\n        }\n        if (this.gui.sideBySide) {\n            easyMDEContainer.removeChild(this.gui.sideBySide);\n        }\n    }\n\n    // Unwrap easyMDEcontainer before codemirror toTextArea() call\n    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);\n    easyMDEContainer.remove();\n\n    cm.toTextArea();\n\n    if (this.autosaveTimeoutId) {\n        clearTimeout(this.autosaveTimeoutId);\n        this.autosaveTimeoutId = undefined;\n        this.clearAutosavedValue();\n    }\n};\n\nmodule.exports = EasyMDE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvZWFzeW1kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFZO0FBQ3JDLG1CQUFPLENBQUMseUdBQXVDO0FBQy9DLG1CQUFPLENBQUMsdUZBQXNCO0FBQzlCLG1CQUFPLENBQUMsMkdBQXdDO0FBQ2hELG1CQUFPLENBQUMsdUdBQXNDO0FBQzlDLG1CQUFPLENBQUMsK0ZBQWtDO0FBQzFDLG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsdUhBQThDO0FBQ3RELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLDZCQUE2QixtQkFBTyxDQUFDLHVHQUEwQjtBQUMvRCxhQUFhLHdGQUF3Qjs7O0FBR3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUEsd0JBQXdCLDhCQUE4QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQXlDOztBQUV6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsd0NBQXdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELGtCQUFrQjtBQUNsQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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QUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0Esd0VBQXdFLG1DQUFtQztBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaXNzdWUtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL3NyYy9qcy9lYXN5bWRlLmpzPzNiMTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIENvZGVNaXJyb3IgPSByZXF1aXJlKCdjb2RlbWlycm9yJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2VkaXQvY29udGludWVsaXN0LmpzJyk7XG5yZXF1aXJlKCcuL2NvZGVtaXJyb3IvdGFibGlzdCcpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2Z1bGxzY3JlZW4uanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS9tYXJrZG93bi9tYXJrZG93bi5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9tb2RlL292ZXJsYXkuanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9wbGFjZWhvbGRlci5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L2F1dG9yZWZyZXNoLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL3NlbGVjdGlvbi9tYXJrLXNlbGVjdGlvbi5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9zZWFyY2gvc2VhcmNoY3Vyc29yLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUvZ2ZtL2dmbS5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL3htbC94bWwuanMnKTtcbnZhciBDb2RlTWlycm9yU3BlbGxDaGVja2VyID0gcmVxdWlyZSgnY29kZW1pcnJvci1zcGVsbC1jaGVja2VyJyk7XG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJykubWFya2VkO1xuXG5cbi8vIFNvbWUgdmFyaWFibGVzXG52YXIgaXNNYWMgPSAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgYW5jaG9yVG9FeHRlcm5hbFJlZ2V4ID0gbmV3IFJlZ0V4cCgvKDxhLio/aHR0cHM/OlxcL1xcLy4qP1teYV0+KSs/L2cpO1xuXG4vLyBNYXBwaW5nIG9mIGFjdGlvbnMgdGhhdCBjYW4gYmUgYm91bmQgdG8ga2V5Ym9hcmQgc2hvcnRjdXRzIG9yIHRvb2xiYXIgYnV0dG9uc1xudmFyIGJpbmRpbmdzID0ge1xuICAgICd0b2dnbGVCb2xkJzogdG9nZ2xlQm9sZCxcbiAgICAndG9nZ2xlSXRhbGljJzogdG9nZ2xlSXRhbGljLFxuICAgICdkcmF3TGluayc6IGRyYXdMaW5rLFxuICAgICd0b2dnbGVIZWFkaW5nU21hbGxlcic6IHRvZ2dsZUhlYWRpbmdTbWFsbGVyLFxuICAgICd0b2dnbGVIZWFkaW5nQmlnZ2VyJzogdG9nZ2xlSGVhZGluZ0JpZ2dlcixcbiAgICAnZHJhd0ltYWdlJzogZHJhd0ltYWdlLFxuICAgICd0b2dnbGVCbG9ja3F1b3RlJzogdG9nZ2xlQmxvY2txdW90ZSxcbiAgICAndG9nZ2xlT3JkZXJlZExpc3QnOiB0b2dnbGVPcmRlcmVkTGlzdCxcbiAgICAndG9nZ2xlVW5vcmRlcmVkTGlzdCc6IHRvZ2dsZVVub3JkZXJlZExpc3QsXG4gICAgJ3RvZ2dsZUNvZGVCbG9jayc6IHRvZ2dsZUNvZGVCbG9jayxcbiAgICAndG9nZ2xlUHJldmlldyc6IHRvZ2dsZVByZXZpZXcsXG4gICAgJ3RvZ2dsZVN0cmlrZXRocm91Z2gnOiB0b2dnbGVTdHJpa2V0aHJvdWdoLFxuICAgICd0b2dnbGVIZWFkaW5nMSc6IHRvZ2dsZUhlYWRpbmcxLFxuICAgICd0b2dnbGVIZWFkaW5nMic6IHRvZ2dsZUhlYWRpbmcyLFxuICAgICd0b2dnbGVIZWFkaW5nMyc6IHRvZ2dsZUhlYWRpbmczLFxuICAgICd0b2dnbGVIZWFkaW5nNCc6IHRvZ2dsZUhlYWRpbmc0LFxuICAgICd0b2dnbGVIZWFkaW5nNSc6IHRvZ2dsZUhlYWRpbmc1LFxuICAgICd0b2dnbGVIZWFkaW5nNic6IHRvZ2dsZUhlYWRpbmc2LFxuICAgICdjbGVhbkJsb2NrJzogY2xlYW5CbG9jayxcbiAgICAnZHJhd1RhYmxlJzogZHJhd1RhYmxlLFxuICAgICdkcmF3SG9yaXpvbnRhbFJ1bGUnOiBkcmF3SG9yaXpvbnRhbFJ1bGUsXG4gICAgJ3VuZG8nOiB1bmRvLFxuICAgICdyZWRvJzogcmVkbyxcbiAgICAndG9nZ2xlU2lkZUJ5U2lkZSc6IHRvZ2dsZVNpZGVCeVNpZGUsXG4gICAgJ3RvZ2dsZUZ1bGxTY3JlZW4nOiB0b2dnbGVGdWxsU2NyZWVuLFxufTtcblxudmFyIHNob3J0Y3V0cyA9IHtcbiAgICAndG9nZ2xlQm9sZCc6ICdDbWQtQicsXG4gICAgJ3RvZ2dsZUl0YWxpYyc6ICdDbWQtSScsXG4gICAgJ2RyYXdMaW5rJzogJ0NtZC1LJyxcbiAgICAndG9nZ2xlSGVhZGluZ1NtYWxsZXInOiAnQ21kLUgnLFxuICAgICd0b2dnbGVIZWFkaW5nQmlnZ2VyJzogJ1NoaWZ0LUNtZC1IJyxcbiAgICAndG9nZ2xlSGVhZGluZzEnOiAnQ3RybCtBbHQrMScsXG4gICAgJ3RvZ2dsZUhlYWRpbmcyJzogJ0N0cmwrQWx0KzInLFxuICAgICd0b2dnbGVIZWFkaW5nMyc6ICdDdHJsK0FsdCszJyxcbiAgICAndG9nZ2xlSGVhZGluZzQnOiAnQ3RybCtBbHQrNCcsXG4gICAgJ3RvZ2dsZUhlYWRpbmc1JzogJ0N0cmwrQWx0KzUnLFxuICAgICd0b2dnbGVIZWFkaW5nNic6ICdDdHJsK0FsdCs2JyxcbiAgICAnY2xlYW5CbG9jayc6ICdDbWQtRScsXG4gICAgJ2RyYXdJbWFnZSc6ICdDbWQtQWx0LUknLFxuICAgICd0b2dnbGVCbG9ja3F1b3RlJzogJ0NtZC1cXCcnLFxuICAgICd0b2dnbGVPcmRlcmVkTGlzdCc6ICdDbWQtQWx0LUwnLFxuICAgICd0b2dnbGVVbm9yZGVyZWRMaXN0JzogJ0NtZC1MJyxcbiAgICAndG9nZ2xlQ29kZUJsb2NrJzogJ0NtZC1BbHQtQycsXG4gICAgJ3RvZ2dsZVByZXZpZXcnOiAnQ21kLVAnLFxuICAgICd0b2dnbGVTaWRlQnlTaWRlJzogJ0Y5JyxcbiAgICAndG9nZ2xlRnVsbFNjcmVlbic6ICdGMTEnLFxufTtcblxudmFyIGdldEJpbmRpbmdOYW1lID0gZnVuY3Rpb24gKGYpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gYmluZGluZ3MpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdzW2tleV0gPT09IGYpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgaXNNb2JpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vfGFuZHJvaWR8aXBhZHxwbGF5Ym9va3xzaWxrL2kudGVzdChhKSB8fCAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298cy0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8LW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxidy0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbS18Y2VsbHxjaHRtfGNsZGN8Y21kLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkYy1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZi01fGctbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZC0obXxwfHQpfGhlaS18aGkocHR8dGEpfGhwKCBpfGlwKXxocy1jfGh0KGMoLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGktKDIwfGdvfG1hKXxpMjMwfGlhYyggfC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Yy18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8LVthLXddKXxsaWJ3fGx5bnh8bTEtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG0tY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8LShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwbi0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHQtZ3xxYS1hfHFjKDA3fDEyfDIxfDMyfDYwfC1bMi03XXxpLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGgtfG9vfHAtKXxzZGtcXC98c2UoYygtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaC18c2hhcnxzaWUoLXxtKXxzay0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGgtfHYtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsLXx0ZGctfHRlbChpfG0pfHRpbS18dC1tb3x0byhwbHxzaCl8dHMoNzB8bS18bTN8bTUpfHR4LTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXMtfHlvdXJ8emV0b3x6dGUtL2kudGVzdChhLnN1YnN0cigwLCA0KSkpIGNoZWNrID0gdHJ1ZTtcbiAgICB9KShuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhKTtcbiAgICByZXR1cm4gY2hlY2s7XG59O1xuXG4vKipcbiAqIE1vZGlmeSBIVE1MIHRvIGFkZCAndGFyZ2V0PVwiX2JsYW5rXCInIHRvIGxpbmtzIHNvIHRoZXkgb3BlbiBpbiBuZXcgdGFicyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxUZXh0IC0gSFRNTCB0byBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1vZGlmaWVkIEhUTUwgdGV4dC5cbiAqL1xuZnVuY3Rpb24gYWRkQW5jaG9yVGFyZ2V0QmxhbmsoaHRtbFRleHQpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IGFuY2hvclRvRXh0ZXJuYWxSZWdleC5leGVjKGh0bWxUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2l0aCBvbmx5IG9uZSBjYXB0dXJlIGdyb3VwIGluIHRoZSBSZWdFeHAsIHdlIGNhbiBzYWZlbHkgdGFrZSB0aGUgZmlyc3QgaW5kZXggZnJvbSB0aGUgbWF0Y2guXG4gICAgICAgIHZhciBsaW5rU3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICAgICAgaWYgKGxpbmtTdHJpbmcuaW5kZXhPZigndGFyZ2V0PScpID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkTGlua1N0cmluZyA9IGxpbmtTdHJpbmcucmVwbGFjZSgvPiQvLCAnIHRhcmdldD1cIl9ibGFua1wiPicpO1xuICAgICAgICAgICAgaHRtbFRleHQgPSBodG1sVGV4dC5yZXBsYWNlKGxpbmtTdHJpbmcsIGZpeGVkTGlua1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWxUZXh0O1xufVxuXG4vKipcbiAqIE1vZGlmeSBIVE1MIHRvIHJlbW92ZSB0aGUgbGlzdC1zdHlsZSB3aGVuIHJlbmRlcmluZyBjaGVja2JveGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxUZXh0IC0gSFRNTCB0byBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1vZGlmaWVkIEhUTUwgdGV4dC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdFN0eWxlV2hlbkNoZWNrYm94KGh0bWxUZXh0KSB7XG5cbiAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIHZhciBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sVGV4dCwgJ3RleHQvaHRtbCcpO1xuICAgIHZhciBsaXN0SXRlbXMgPSBodG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gbGlzdEl0ZW1zW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlzdEl0ZW0uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0SXRlbUNoaWxkID0gbGlzdEl0ZW0uY2hpbGRyZW5bal07XG5cbiAgICAgICAgICAgIGlmIChsaXN0SXRlbUNoaWxkIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBsaXN0SXRlbUNoaWxkLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAvLyBGcm9tIEdpdGh1YjogbWFyZ2luOiAwIC4yZW0gLjI1ZW0gLTEuNmVtO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnN0eWxlLm1hcmdpbkxlZnQgPSAnLTEuNWVtJztcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5zdHlsZS5saXN0U3R5bGVUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxEb2MuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTDtcbn1cblxuLyoqXG4gKiBGaXggc2hvcnRjdXQuIE1hYyB1c2UgQ29tbWFuZCwgb3RoZXJzIHVzZSBDdHJsLlxuICovXG5mdW5jdGlvbiBmaXhTaG9ydGN1dChuYW1lKSB7XG4gICAgaWYgKGlzTWFjKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoJ0N0cmwnLCAnQ21kJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgnQ21kJywgJ0N0cmwnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGRyb3Bkb3duIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2xiYXJEcm9wZG93bihvcHRpb25zLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCBwYXJlbnQpIHtcbiAgICB2YXIgZWwgPSBjcmVhdGVUb29sYmFyQnV0dG9uKG9wdGlvbnMsIGZhbHNlLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCAnYnV0dG9uJywgcGFyZW50KTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdlYXN5bWRlLWRyb3Bkb3duJyk7XG5cbiAgICBlbC5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5mb2N1cygpO1xuICAgIH07XG5cbiAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ2Vhc3ltZGUtZHJvcGRvd24tY29udGVudCc7XG4gICAgZm9yICh2YXIgY2hpbGRyZW5JbmRleCA9IDA7IGNoaWxkcmVuSW5kZXggPCBvcHRpb25zLmNoaWxkcmVuLmxlbmd0aDsgY2hpbGRyZW5JbmRleCsrKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkID0gb3B0aW9ucy5jaGlsZHJlbltjaGlsZHJlbkluZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkRWxlbWVudDtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyAmJiBjaGlsZCBpbiB0b29sYmFyQnVpbHRJbkJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24odG9vbGJhckJ1aWx0SW5CdXR0b25zW2NoaWxkXSwgdHJ1ZSwgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgJ2J1dHRvbicsIHBhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZEVsZW1lbnQgPSBjcmVhdGVUb29sYmFyQnV0dG9uKGNoaWxkLCB0cnVlLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCAnYnV0dG9uJywgcGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH0sIGZhbHNlKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChjaGlsZEVsZW1lbnQpO1xuICAgIH1cbiAgICBlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ3JlYXRlIGJ1dHRvbiBlbGVtZW50IGZvciB0b29sYmFyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFyQnV0dG9uKG9wdGlvbnMsIGVuYWJsZUFjdGlvbnMsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsIG1hcmt1cCwgcGFyZW50KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChtYXJrdXApO1xuXG4gICAgLy8gQWRkICdjdXN0b20nIGF0dHJpYnV0ZXMgYXMgZWFybHkgYXMgcG9zc2libGUsIHNvIHRoYXQgJ29mZmljaWFsJyBhdHRyaWJ1dGVzIHdpbGwgbmV2ZXIgYmUgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMuYXR0cmlidXRlcywgYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIG9wdGlvbnMuYXR0cmlidXRlc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWVQcmVmaXggPSBwYXJlbnQub3B0aW9ucy50b29sYmFyQnV0dG9uQ2xhc3NQcmVmaXggPyBwYXJlbnQub3B0aW9ucy50b29sYmFyQnV0dG9uQ2xhc3NQcmVmaXggKyAnLScgOiAnJztcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVQcmVmaXggKyBvcHRpb25zLm5hbWU7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgbWFya3VwKTtcbiAgICBlbmFibGVUb29sdGlwcyA9IChlbmFibGVUb29sdGlwcyA9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGVuYWJsZVRvb2x0aXBzO1xuXG4gICAgaWYgKG9wdGlvbnMudGV4dCkge1xuICAgICAgICBlbC5pbm5lclRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgfVxuXG4gICAgLy8gUHJvcGVybHkgaGFuZGxlIGN1c3RvbSBzaG9ydGN1dHNcbiAgICBpZiAob3B0aW9ucy5uYW1lICYmIG9wdGlvbnMubmFtZSBpbiBzaG9ydGN1dHMpIHtcbiAgICAgICAgYmluZGluZ3Nbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnMuYWN0aW9uO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpdGxlICYmIGVuYWJsZVRvb2x0aXBzKSB7XG4gICAgICAgIGVsLnRpdGxlID0gY3JlYXRlVG9vbHRpcChvcHRpb25zLnRpdGxlLCBvcHRpb25zLmFjdGlvbiwgc2hvcnRjdXRzKTtcblxuICAgICAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgICAgIGVsLnRpdGxlID0gZWwudGl0bGUucmVwbGFjZSgnQ3RybCcsICfijJgnKTtcbiAgICAgICAgICAgIGVsLnRpdGxlID0gZWwudGl0bGUucmVwbGFjZSgnQWx0JywgJ+KMpScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgb3B0aW9ucy50aXRsZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9EaXNhYmxlKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ25vLWRpc2FibGUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub01vYmlsZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCduby1tb2JpbGUnKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGVycm9ycyBpZiB0aGVyZSBpcyBubyBjbGFzcyBuYW1lIGluIGN1c3RvbSBvcHRpb25zXG4gICAgdmFyIGNsYXNzTmFtZVBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2xhc3NOYW1lUGFydHMgPSBvcHRpb25zLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIC8vIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBzaW1wbGUtbWFya2Rvd24tZWRpdG9yIGJ5IGFkZGluZyBjdXN0b20gY2xhc3NlcyB0byB0aGUgYnV0dG9uLlxuICAgIHZhciBpY29uQ2xhc3NlcyA9IFtdO1xuICAgIGZvciAodmFyIGNsYXNzTmFtZUluZGV4ID0gMDsgY2xhc3NOYW1lSW5kZXggPCBjbGFzc05hbWVQYXJ0cy5sZW5ndGg7IGNsYXNzTmFtZUluZGV4KyspIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZVBhcnQgPSBjbGFzc05hbWVQYXJ0c1tjbGFzc05hbWVJbmRleF07XG4gICAgICAgIC8vIFNwbGl0IGljb24gY2xhc3NlcyBmcm9tIHRoZSBidXR0b24uXG4gICAgICAgIC8vIFJlZ2V4IHdpbGwgZGV0ZWN0IFwiZmFcIiwgXCJmYXNcIiwgXCJmYS1zb21ldGhpbmdcIiBhbmQgXCJmYS1zb21lLWljb24tMVwiLCBidXQgbm90IFwiZmFuZmFyZVwiLlxuICAgICAgICBpZiAoY2xhc3NOYW1lUGFydC5tYXRjaCgvXmZhKFtzcmxiXXwoLVtcXHctXSopfCQpLykpIHtcbiAgICAgICAgICAgIGljb25DbGFzc2VzLnB1c2goY2xhc3NOYW1lUGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZVBhcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWwudGFiSW5kZXggPSAtMTtcblxuICAgIGlmIChpY29uQ2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIENyZWF0ZSBpY29uIGVsZW1lbnQgYW5kIGFwcGVuZCBhcyBhIGNoaWxkIHRvIHRoZSBidXR0b25cbiAgICAgICAgdmFyIGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG4gICAgICAgIGZvciAodmFyIGljb25DbGFzc0luZGV4ID0gMDsgaWNvbkNsYXNzSW5kZXggPCBpY29uQ2xhc3Nlcy5sZW5ndGg7IGljb25DbGFzc0luZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBpY29uQ2xhc3MgPSBpY29uQ2xhc3Nlc1tpY29uQ2xhc3NJbmRleF07XG4gICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoaWNvbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5hcHBlbmRDaGlsZChpY29uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGN1c3RvbSBpY29uIG1hcmt1cCBzZXQsIHVzZSB0aGF0XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmljb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IG9wdGlvbnMuaWNvbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hY3Rpb24gJiYgZW5hYmxlQWN0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlbC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hY3Rpb24ocGFyZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWwub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKG9wdGlvbnMuYWN0aW9uLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZXAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuICAgIGVsLmNsYXNzTmFtZSA9ICdzZXBhcmF0b3InO1xuICAgIGVsLmlubmVySFRNTCA9ICd8JztcbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXAodGl0bGUsIGFjdGlvbiwgc2hvcnRjdXRzKSB7XG4gICAgdmFyIGFjdGlvbk5hbWU7XG4gICAgdmFyIHRvb2x0aXAgPSB0aXRsZTtcblxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgYWN0aW9uTmFtZSA9IGdldEJpbmRpbmdOYW1lKGFjdGlvbik7XG4gICAgICAgIGlmIChzaG9ydGN1dHNbYWN0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHRvb2x0aXAgKz0gJyAoJyArIGZpeFNob3J0Y3V0KHNob3J0Y3V0c1thY3Rpb25OYW1lXSkgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9vbHRpcDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgb2YgQ29kZU1pcnJvciBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlKGNtLCBwb3MpIHtcbiAgICBwb3MgPSBwb3MgfHwgY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBzdGF0ID0gY20uZ2V0VG9rZW5BdChwb3MpO1xuICAgIGlmICghc3RhdC50eXBlKSByZXR1cm4ge307XG5cbiAgICB2YXIgdHlwZXMgPSBzdGF0LnR5cGUuc3BsaXQoJyAnKTtcblxuICAgIHZhciByZXQgPSB7fSxcbiAgICAgICAgZGF0YSwgdGV4dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKGRhdGEgPT09ICdzdHJvbmcnKSB7XG4gICAgICAgICAgICByZXQuYm9sZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ3ZhcmlhYmxlLTInKSB7XG4gICAgICAgICAgICB0ZXh0ID0gY20uZ2V0TGluZShwb3MubGluZSk7XG4gICAgICAgICAgICBpZiAoL15cXHMqXFxkK1xcLlxccy8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldFsnb3JkZXJlZC1saXN0J10gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbJ3Vub3JkZXJlZC1saXN0J10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdhdG9tJykge1xuICAgICAgICAgICAgcmV0LnF1b3RlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnZW0nKSB7XG4gICAgICAgICAgICByZXQuaXRhbGljID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAncXVvdGUnKSB7XG4gICAgICAgICAgICByZXQucXVvdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdzdHJpa2V0aHJvdWdoJykge1xuICAgICAgICAgICAgcmV0LnN0cmlrZXRocm91Z2ggPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdjb21tZW50Jykge1xuICAgICAgICAgICAgcmV0LmNvZGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdsaW5rJyAmJiAhcmV0LmltYWdlKSB7XG4gICAgICAgICAgICByZXQubGluayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgcmV0LmltYWdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLm1hdGNoKC9eaGVhZGVyKC1bMS02XSk/JC8pKSB7XG4gICAgICAgICAgICByZXRbZGF0YS5yZXBsYWNlKCdoZWFkZXInLCAnaGVhZGluZycpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuXG4vLyBTYXZlZCBvdmVyZmxvdyBzZXR0aW5nXG52YXIgc2F2ZWRfb3ZlcmZsb3cgPSAnJztcblxuLyoqXG4gKiBUb2dnbGUgZnVsbCBzY3JlZW4gb2YgdGhlIGVkaXRvci5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUZ1bGxTY3JlZW4oZWRpdG9yKSB7XG4gICAgLy8gU2V0IGZ1bGxzY3JlZW5cbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICBjbS5zZXRPcHRpb24oJ2Z1bGxTY3JlZW4nLCAhY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpO1xuXG5cbiAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBib2R5IGR1cmluZyBmdWxsc2NyZWVuIGFjdGl2ZVxuICAgIGlmIChjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkge1xuICAgICAgICBzYXZlZF9vdmVyZmxvdyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gc2F2ZWRfb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBzaWRlYnlzaWRlID0gd3JhcHBlci5uZXh0U2libGluZztcblxuICAgIGlmIChzaWRlYnlzaWRlLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKSkge1xuICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMuc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBpZiBzaWRlLWJ5LXNpZGUgbm90LWZ1bGxzY3JlZW4gb2ssIGFwcGx5IGNsYXNzZXMgYXMgbmVlZGVkXG4gICAgICAgICAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IHdyYXBwZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkge1xuICAgICAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2lkZWQtLW5vLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9nZ2xlU2lkZUJ5U2lkZShlZGl0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkaXRvci5vcHRpb25zLm9uVG9nZ2xlRnVsbFNjcmVlbikge1xuICAgICAgICBlZGl0b3Iub3B0aW9ucy5vblRvZ2dsZUZ1bGxTY3JlZW4oY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBvciBzZXQgbWF4SGVpZ2h0XG4gICAgaWYgKHR5cGVvZiBlZGl0b3Iub3B0aW9ucy5tYXhIZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkge1xuICAgICAgICAgICAgY20uZ2V0U2Nyb2xsZXJFbGVtZW50KCkuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICAgICAgc2lkZWJ5c2lkZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbS5nZXRTY3JvbGxlckVsZW1lbnQoKS5zdHlsZS5oZWlnaHQgPSBlZGl0b3Iub3B0aW9ucy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0UHJldmlld01heEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRvb2xiYXIgY2xhc3NcbiAgICBlZGl0b3IudG9vbGJhcl9kaXYuY2xhc3NMaXN0LnRvZ2dsZSgnZnVsbHNjcmVlbicpO1xuXG4gICAgLy8gVXBkYXRlIHRvb2xiYXIgYnV0dG9uXG4gICAgaWYgKGVkaXRvci50b29sYmFyRWxlbWVudHMgJiYgZWRpdG9yLnRvb2xiYXJFbGVtZW50cy5mdWxsc2NyZWVuKSB7XG4gICAgICAgIHZhciB0b29sYmFyQnV0dG9uID0gZWRpdG9yLnRvb2xiYXJFbGVtZW50cy5mdWxsc2NyZWVuO1xuICAgICAgICB0b29sYmFyQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgYm9sZC5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUJvbGQoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUJsb2NrKGVkaXRvciwgJ2JvbGQnLCBlZGl0b3Iub3B0aW9ucy5ibG9ja1N0eWxlcy5ib2xkKTtcbn1cblxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaXRhbGljLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSXRhbGljKGVkaXRvcikge1xuICAgIF90b2dnbGVCbG9jayhlZGl0b3IsICdpdGFsaWMnLCBlZGl0b3Iub3B0aW9ucy5ibG9ja1N0eWxlcy5pdGFsaWMpO1xufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBzdHJpa2V0aHJvdWdoLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlU3RyaWtldGhyb3VnaChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlQmxvY2soZWRpdG9yLCAnc3RyaWtldGhyb3VnaCcsICd+ficpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgY29kZSBibG9jay5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNvZGVCbG9jayhlZGl0b3IpIHtcbiAgICB2YXIgZmVuY2VDaGFyc1RvSW5zZXJ0ID0gZWRpdG9yLm9wdGlvbnMuYmxvY2tTdHlsZXMuY29kZTtcblxuICAgIGZ1bmN0aW9uIGZlbmNpbmdfbGluZShsaW5lKSB7XG4gICAgICAgIC8qIHJldHVybiB0cnVlLCBpZiB0aGlzIGlzIGEgYGBgIG9yIH5+fiBsaW5lICovXG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93ICdmZW5jaW5nX2xpbmUoKSB0YWtlcyBhIFxcJ2xpbmVcXCcgb2JqZWN0IChub3QgYSBsaW5lIG51bWJlciwgb3IgbGluZSB0ZXh0KS4gIEdvdDogJyArIHR5cGVvZiBsaW5lICsgJzogJyArIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUuc3R5bGVzICYmIGxpbmUuc3R5bGVzWzJdICYmIGxpbmUuc3R5bGVzWzJdLmluZGV4T2YoJ2Zvcm1hdHRpbmctY29kZS1ibG9jaycpICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbl9zdGF0ZSh0b2tlbikge1xuICAgICAgICAvLyBiYXNlIGdvZXMgYW4gZXh0cmEgbGV2ZWwgZGVlcCB3aGVuIG1vZGUgYmFja2Ryb3BzIGFyZSB1c2VkLCBlLmcuIHNwZWxsY2hlY2tlciBvblxuICAgICAgICByZXR1cm4gdG9rZW4uc3RhdGUuYmFzZS5iYXNlIHx8IHRva2VuLnN0YXRlLmJhc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29kZV90eXBlKGNtLCBsaW5lX251bSwgbGluZSwgZmlyc3RUb2ssIGxhc3RUb2spIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJuIFwic2luZ2xlXCIsIFwiaW5kZW50ZWRcIiwgXCJmZW5jZWRcIiBvciBmYWxzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBjbSBhbmQgbGluZV9udW0gYXJlIHJlcXVpcmVkLiAgT3RoZXJzIGFyZSBvcHRpb25hbCBmb3IgZWZmaWNpZW5jeVxuICAgICAgICAgKiAgIFRvIGNoZWNrIGluIHRoZSBtaWRkbGUgb2YgYSBsaW5lLCBwYXNzIGluIGZpcnN0VG9rIHlvdXJzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgbGluZSA9IGxpbmUgfHwgY20uZ2V0TGluZUhhbmRsZShsaW5lX251bSk7XG4gICAgICAgIGZpcnN0VG9rID0gZmlyc3RUb2sgfHwgY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lX251bSxcbiAgICAgICAgICAgIGNoOiAxLFxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdFRvayA9IGxhc3RUb2sgfHwgKCEhbGluZS50ZXh0ICYmIGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgbGluZTogbGluZV9udW0sXG4gICAgICAgICAgICBjaDogbGluZS50ZXh0Lmxlbmd0aCAtIDEsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHR5cGVzID0gZmlyc3RUb2sudHlwZSA/IGZpcnN0VG9rLnR5cGUuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICBpZiAobGFzdFRvayAmJiB0b2tlbl9zdGF0ZShsYXN0VG9rKS5pbmRlbnRlZENvZGUpIHtcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gY2hlY2sgbGFzdCBjaGFyLCBzaW5jZSBmaXJzdCBjaGFycyBvZiBmaXJzdCBsaW5lIGFyZW5cInQgbWFya2VkIGFzIGluZGVudGVkXG4gICAgICAgICAgICByZXR1cm4gJ2luZGVudGVkJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlcy5pbmRleE9mKCdjb21tZW50JykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBoYXMgdG8gYmUgYWZ0ZXIgXCJpbmRlbnRlZFwiIGNoZWNrLCBzaW5jZSBmaXJzdCBjaGFycyBvZiBmaXJzdCBpbmRlbnRlZCBsaW5lIGFyZW5cInQgbWFya2VkIGFzIHN1Y2hcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbl9zdGF0ZShmaXJzdFRvaykuZmVuY2VkQ2hhcnMgfHwgdG9rZW5fc3RhdGUobGFzdFRvaykuZmVuY2VkQ2hhcnMgfHwgZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ZlbmNlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NpbmdsZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnRGZW5jaW5nQXRTZWxlY3Rpb24oY20sIGN1cl9zdGFydCwgY3VyX2VuZCwgZmVuY2VDaGFyc1RvSW5zZXJ0KSB7XG4gICAgICAgIHZhciBzdGFydF9saW5lX3NlbCA9IGN1cl9zdGFydC5saW5lICsgMSxcbiAgICAgICAgICAgIGVuZF9saW5lX3NlbCA9IGN1cl9lbmQubGluZSArIDEsXG4gICAgICAgICAgICBzZWxfbXVsdGkgPSBjdXJfc3RhcnQubGluZSAhPT0gY3VyX2VuZC5saW5lLFxuICAgICAgICAgICAgcmVwbF9zdGFydCA9IGZlbmNlQ2hhcnNUb0luc2VydCArICdcXG4nLFxuICAgICAgICAgICAgcmVwbF9lbmQgPSAnXFxuJyArIGZlbmNlQ2hhcnNUb0luc2VydDtcbiAgICAgICAgaWYgKHNlbF9tdWx0aSkge1xuICAgICAgICAgICAgZW5kX2xpbmVfc2VsKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGxhc3QgY2hhciBpbmNsdWRpbmcgXFxuIG9yIG5vdFxuICAgICAgICBpZiAoc2VsX211bHRpICYmIGN1cl9lbmQuY2ggPT09IDApIHtcbiAgICAgICAgICAgIHJlcGxfZW5kID0gZmVuY2VDaGFyc1RvSW5zZXJ0ICsgJ1xcbic7XG4gICAgICAgICAgICBlbmRfbGluZV9zZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgZmFsc2UsIFtyZXBsX3N0YXJ0LCByZXBsX2VuZF0pO1xuICAgICAgICBjbS5zZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgbGluZTogc3RhcnRfbGluZV9zZWwsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogZW5kX2xpbmVfc2VsLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yLFxuICAgICAgICBjdXJfc3RhcnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0JyksXG4gICAgICAgIGN1cl9lbmQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpLFxuICAgICAgICB0b2sgPSBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgIGxpbmU6IGN1cl9zdGFydC5saW5lLFxuICAgICAgICAgICAgY2g6IGN1cl9zdGFydC5jaCB8fCAxLFxuICAgICAgICB9KSwgLy8gYXZvaWQgY2ggMCB3aGljaCBpcyBhIGN1cnNvciBwb3MgYnV0IG5vdCB0b2tlblxuICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShjdXJfc3RhcnQubGluZSksXG4gICAgICAgIGlzX2NvZGUgPSBjb2RlX3R5cGUoY20sIGN1cl9zdGFydC5saW5lLCBsaW5lLCB0b2spO1xuICAgIHZhciBibG9ja19zdGFydCwgYmxvY2tfZW5kLCBsaW5lQ291bnQ7XG5cbiAgICBpZiAoaXNfY29kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgLy8gc2ltaWxhciB0byBzb21lIEVhc3lNREUgX3RvZ2dsZUJsb2NrIGxvZ2ljXG4gICAgICAgIHZhciBzdGFydCA9IGxpbmUudGV4dC5zbGljZSgwLCBjdXJfc3RhcnQuY2gpLnJlcGxhY2UoJ2AnLCAnJyksXG4gICAgICAgICAgICBlbmQgPSBsaW5lLnRleHQuc2xpY2UoY3VyX3N0YXJ0LmNoKS5yZXBsYWNlKCdgJywgJycpO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2Uoc3RhcnQgKyBlbmQsIHtcbiAgICAgICAgICAgIGxpbmU6IGN1cl9zdGFydC5saW5lLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxpbmU6IGN1cl9zdGFydC5saW5lLFxuICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICB9KTtcbiAgICAgICAgY3VyX3N0YXJ0LmNoLS07XG4gICAgICAgIGlmIChjdXJfc3RhcnQgIT09IGN1cl9lbmQpIHtcbiAgICAgICAgICAgIGN1cl9lbmQuY2gtLTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24oY3VyX3N0YXJ0LCBjdXJfZW5kKTtcbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKGlzX2NvZGUgPT09ICdmZW5jZWQnKSB7XG4gICAgICAgIGlmIChjdXJfc3RhcnQubGluZSAhPT0gY3VyX2VuZC5saW5lIHx8IGN1cl9zdGFydC5jaCAhPT0gY3VyX2VuZC5jaCkge1xuICAgICAgICAgICAgLy8gdXNlIHNlbGVjdGlvblxuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBmZW5jZWQgbGluZSBzbyB3ZSBrbm93IHdoYXQgdHlwZSBpdCBpcyAodGlsZGUsIGJhY2t0aWNrcywgbnVtYmVyIG9mIHRoZW0pXG4gICAgICAgICAgICBmb3IgKGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7IGJsb2NrX3N0YXJ0ID49IDA7IGJsb2NrX3N0YXJ0LS0pIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmVuY2VkVG9rID0gY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICAgICAgbGluZTogYmxvY2tfc3RhcnQsXG4gICAgICAgICAgICAgICAgY2g6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBmZW5jZV9jaGFycyA9IHRva2VuX3N0YXRlKGZlbmNlZFRvaykuZmVuY2VkQ2hhcnM7XG4gICAgICAgICAgICB2YXIgc3RhcnRfdGV4dCwgc3RhcnRfbGluZTtcbiAgICAgICAgICAgIHZhciBlbmRfdGV4dCwgZW5kX2xpbmU7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc2VsZWN0aW9uIGdvaW5nIHVwIGFnYWluc3QgZmVuY2VkIGxpbmVzLCBpbiB3aGljaCBjYXNlIHdlIGRvbid0IHdhbnQgdG8gYWRkIG1vcmUgZmVuY2luZ1xuICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lKSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydF90ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgc3RhcnRfbGluZSA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfc3RhcnQubGluZSAtIDEpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBzdGFydF9saW5lID0gY3VyX3N0YXJ0LmxpbmUgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydF90ZXh0ID0gZmVuY2VfY2hhcnMgKyAnXFxuJztcbiAgICAgICAgICAgICAgICBzdGFydF9saW5lID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX2VuZC5saW5lKSkpIHtcbiAgICAgICAgICAgICAgICBlbmRfdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIGVuZF9saW5lID0gY3VyX2VuZC5saW5lO1xuICAgICAgICAgICAgICAgIGlmIChjdXJfZW5kLmNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZF9saW5lICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJfZW5kLmNoICE9PSAwICYmIGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9lbmQubGluZSArIDEpKSkge1xuICAgICAgICAgICAgICAgIGVuZF90ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgZW5kX2xpbmUgPSBjdXJfZW5kLmxpbmUgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRfdGV4dCA9IGZlbmNlX2NoYXJzICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgZW5kX2xpbmUgPSBjdXJfZW5kLmxpbmUgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cl9lbmQuY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmdWxsIGxhc3QgbGluZSBzZWxlY3RlZCwgcHV0dGluZyBjdXJzb3IgYXQgYmVnaW5uaW5nIG9mIG5leHRcbiAgICAgICAgICAgICAgICBlbmRfbGluZSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBlbmQgbGluZSBmaXJzdCwgc28gdGhhdCBsaW5lIG51bWJlcnMgZG9uJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGVuZF90ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVuZF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVuZF9saW5lICsgKGVuZF90ZXh0ID8gMCA6IDEpLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2Uoc3RhcnRfdGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0X2xpbmUgKyAoc3RhcnRfdGV4dCA/IDAgOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnRfbGluZSArIChzdGFydF90ZXh0ID8gMSA6IDApLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxpbmU6IGVuZF9saW5lICsgKHN0YXJ0X3RleHQgPyAxIDogLTEpLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gc2VsZWN0aW9uLCBzZWFyY2ggZm9yIGVuZHMgb2YgdGhpcyBmZW5jZWQgYmxvY2tcbiAgICAgICAgICAgIHZhciBzZWFyY2hfZnJvbSA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lKSkpIHsgLy8gZ2V0cyBhIGxpdHRsZSB0cmlja3kgaWYgY3Vyc29yIGlzIHJpZ2h0IG9uIGEgZmVuY2VkIGxpbmVcbiAgICAgICAgICAgICAgICBpZiAoY29kZV90eXBlKGNtLCBjdXJfc3RhcnQubGluZSArIDEpID09PSAnZmVuY2VkJykge1xuICAgICAgICAgICAgICAgICAgICBibG9ja19zdGFydCA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfZnJvbSA9IGN1cl9zdGFydC5saW5lICsgMTsgLy8gZm9yIHNlYXJjaGluZyBmb3IgXCJlbmRcIlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX2VuZCA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfZnJvbSA9IGN1cl9zdGFydC5saW5lIC0gMTsgLy8gZm9yIHNlYXJjaGluZyBmb3IgXCJzdGFydFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrX3N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGJsb2NrX3N0YXJ0ID0gc2VhcmNoX2Zyb207IGJsb2NrX3N0YXJ0ID49IDA7IGJsb2NrX3N0YXJ0LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja19lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxpbmVDb3VudCA9IGNtLmxpbmVDb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAoYmxvY2tfZW5kID0gc2VhcmNoX2Zyb207IGJsb2NrX2VuZCA8IGxpbmVDb3VudDsgYmxvY2tfZW5kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNpbmdfbGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19zdGFydCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19lbmQgLSAxLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX2VuZCxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzX2NvZGUgPT09ICdpbmRlbnRlZCcpIHtcbiAgICAgICAgaWYgKGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmUgfHwgY3VyX3N0YXJ0LmNoICE9PSBjdXJfZW5kLmNoKSB7XG4gICAgICAgICAgICAvLyB1c2Ugc2VsZWN0aW9uXG4gICAgICAgICAgICBibG9ja19zdGFydCA9IGN1cl9zdGFydC5saW5lO1xuICAgICAgICAgICAgYmxvY2tfZW5kID0gY3VyX2VuZC5saW5lO1xuICAgICAgICAgICAgaWYgKGN1cl9lbmQuY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICBibG9ja19lbmQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHNlbGVjdGlvbiwgc2VhcmNoIGZvciBlbmRzIG9mIHRoaXMgaW5kZW50ZWQgYmxvY2tcbiAgICAgICAgICAgIGZvciAoYmxvY2tfc3RhcnQgPSBjdXJfc3RhcnQubGluZTsgYmxvY2tfc3RhcnQgPj0gMDsgYmxvY2tfc3RhcnQtLSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0Lm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBvciBhbGwgd2hpdGVzcGFjZSAtIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVfdHlwZShjbSwgYmxvY2tfc3RhcnQsIGxpbmUpICE9PSAnaW5kZW50ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja19zdGFydCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lQ291bnQgPSBjbS5saW5lQ291bnQoKTtcbiAgICAgICAgICAgIGZvciAoYmxvY2tfZW5kID0gY3VyX3N0YXJ0LmxpbmU7IGJsb2NrX2VuZCA8IGxpbmVDb3VudDsgYmxvY2tfZW5kKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19lbmQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHQubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IG9yIGFsbCB3aGl0ZXNwYWNlIC0ga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZV90eXBlKGNtLCBibG9ja19lbmQsIGxpbmUpICE9PSAnaW5kZW50ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja19lbmQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBnb2luZyB0byB1bi1pbmRlbnQgYmFzZWQgb24gYSBzZWxlY3RlZCBzZXQgb2YgbGluZXMsIGFuZCB0aGUgbmV4dCBsaW5lIGlzIGluZGVudGVkIHRvbywgd2UgbmVlZCB0b1xuICAgICAgICAvLyBpbnNlcnQgYSBibGFuayBsaW5lIHNvIHRoYXQgdGhlIG5leHQgbGluZShzKSBjb250aW51ZSB0byBiZSBpbmRlbnRlZCBjb2RlXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX2VuZCArIDEpLFxuICAgICAgICAgICAgbmV4dF9saW5lX2xhc3RfdG9rID0gbmV4dF9saW5lICYmIGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX2VuZCArIDEsXG4gICAgICAgICAgICAgICAgY2g6IG5leHRfbGluZS50ZXh0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5leHRfbGluZV9pbmRlbnRlZCA9IG5leHRfbGluZV9sYXN0X3RvayAmJiB0b2tlbl9zdGF0ZShuZXh0X2xpbmVfbGFzdF90b2spLmluZGVudGVkQ29kZTtcbiAgICAgICAgaWYgKG5leHRfbGluZV9pbmRlbnRlZCkge1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCdcXG4nLCB7XG4gICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kICsgMSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGJsb2NrX3N0YXJ0OyBpIDw9IGJsb2NrX2VuZDsgaSsrKSB7XG4gICAgICAgICAgICBjbS5pbmRlbnRMaW5lKGksICdzdWJ0cmFjdCcpOyAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgZ2V0IHRyYWNrZWQgaW4gdGhlIGhpc3RvcnksIHNvIGNhbid0IGJlIHVuZG9uZSA6KFxuICAgICAgICB9XG4gICAgICAgIGNtLmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zZXJ0IGNvZGUgZm9ybWF0dGluZ1xuICAgICAgICB2YXIgbm9fc2VsX2FuZF9zdGFydGluZ19vZl9saW5lID0gKGN1cl9zdGFydC5saW5lID09PSBjdXJfZW5kLmxpbmUgJiYgY3VyX3N0YXJ0LmNoID09PSBjdXJfZW5kLmNoICYmIGN1cl9zdGFydC5jaCA9PT0gMCk7XG4gICAgICAgIHZhciBzZWxfbXVsdGkgPSBjdXJfc3RhcnQubGluZSAhPT0gY3VyX2VuZC5saW5lO1xuICAgICAgICBpZiAobm9fc2VsX2FuZF9zdGFydGluZ19vZl9saW5lIHx8IHNlbF9tdWx0aSkge1xuICAgICAgICAgICAgaW5zZXJ0RmVuY2luZ0F0U2VsZWN0aW9uKGNtLCBjdXJfc3RhcnQsIGN1cl9lbmQsIGZlbmNlQ2hhcnNUb0luc2VydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgZmFsc2UsIFsnYCcsICdgJ10pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgYmxvY2txdW90ZS5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQmxvY2txdW90ZShlZGl0b3IpIHtcbiAgICBfdG9nZ2xlTGluZShlZGl0b3IuY29kZW1pcnJvciwgJ3F1b3RlJyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemU6IG5vcm1hbCAtPiBoMSAtPiBoMiAtPiBoMyAtPiBoNCAtPiBoNSAtPiBoNiAtPiBub3JtYWxcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZ1NtYWxsZXIoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsICdzbWFsbGVyJyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemU6IG5vcm1hbCAtPiBoNiAtPiBoNSAtPiBoNCAtPiBoMyAtPiBoMiAtPiBoMSAtPiBub3JtYWxcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZ0JpZ2dlcihlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgJ2JpZ2dlcicpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDFcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzEoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgMSk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgMlxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nMihlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCAyKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSAzXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmczKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDMpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzQoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgNCk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgNVxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nNShlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCA1KTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSA2XG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmc2KGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDYpO1xufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyB1bC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlVW5vcmRlcmVkTGlzdChlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcblxuICAgIHZhciBsaXN0U3R5bGUgPSAnKic7IC8vIERlZmF1bHRcbiAgICBpZiAoWyctJywgJysnLCAnKiddLmluY2x1ZGVzKGVkaXRvci5vcHRpb25zLnVub3JkZXJlZExpc3RTdHlsZSkpIHtcbiAgICAgICAgbGlzdFN0eWxlID0gZWRpdG9yLm9wdGlvbnMudW5vcmRlcmVkTGlzdFN0eWxlO1xuICAgIH1cblxuICAgIF90b2dnbGVMaW5lKGNtLCAndW5vcmRlcmVkLWxpc3QnLCBsaXN0U3R5bGUpO1xufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBvbC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlT3JkZXJlZExpc3QoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUxpbmUoZWRpdG9yLmNvZGVtaXJyb3IsICdvcmRlcmVkLWxpc3QnKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGNsZWFuIGJsb2NrIChyZW1vdmUgaGVhZGxpbmUsIGxpc3QsIGJsb2NrcXVvdGUgY29kZSwgbWFya2VycylcbiAqL1xuZnVuY3Rpb24gY2xlYW5CbG9jayhlZGl0b3IpIHtcbiAgICBfY2xlYW5CbG9jayhlZGl0b3IuY29kZW1pcnJvcik7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciBkcmF3aW5nIGEgbGluay5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIGRyYXdMaW5rKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgdmFyIHVybCA9ICdodHRwczovLyc7XG4gICAgaWYgKG9wdGlvbnMucHJvbXB0VVJMcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcHJvbXB0KG9wdGlvbnMucHJvbXB0VGV4dHMubGluaywgdXJsKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBlc2NhcGVQcm9tcHRVUkwocmVzdWx0KTtcbiAgICB9XG4gICAgX3RvZ2dsZUxpbmsoZWRpdG9yLCAnbGluaycsIG9wdGlvbnMuaW5zZXJ0VGV4dHMubGluaywgdXJsKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGRyYXdpbmcgYW4gaW1nLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd0ltYWdlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgdmFyIHVybCA9ICdodHRwczovLyc7XG4gICAgaWYgKG9wdGlvbnMucHJvbXB0VVJMcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcHJvbXB0KG9wdGlvbnMucHJvbXB0VGV4dHMuaW1hZ2UsIHVybCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gZXNjYXBlUHJvbXB0VVJMKHJlc3VsdCk7XG4gICAgfVxuICAgIF90b2dnbGVMaW5rKGVkaXRvciwgJ2ltYWdlJywgb3B0aW9ucy5pbnNlcnRUZXh0cy5pbWFnZSwgdXJsKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW5kIGVzY2FwZSBVUkxzIHRvIHByZXZlbnQgYnJlYWtpbmcgdXAgcmVuZGVyZWQgTWFya2Rvd24gbGlua3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIGxpbmsgb3IgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUHJvbXB0VVJMKHVybCkge1xuICAgIHJldHVybiBlbmNvZGVVUkkodXJsKS5yZXBsYWNlKC8oW1xcXFwoKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIG9wZW5pbmcgdGhlIGJyb3dzZS1maWxlIHdpbmRvdyB0byB1cGxvYWQgYW4gaW1hZ2UgdG8gYSBzZXJ2ZXIuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvciBUaGUgRWFzeU1ERSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZHJhd1VwbG9hZGVkSW1hZ2UoZWRpdG9yKSB7XG4gICAgLy8gVE9ETzogRHJhdyB0aGUgaW1hZ2UgdGVtcGxhdGUgd2l0aCBhIGZha2UgdXJsPyBpZTogJyFbXShpbXBvcnRpbmcgZm9vLnBuZy4uLiknXG4gICAgZWRpdG9yLm9wZW5Ccm93c2VGaWxlV2luZG93KCk7XG59XG5cbi8qKlxuICogQWN0aW9uIGV4ZWN1dGVkIGFmdGVyIGFuIGltYWdlIGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgaW1wb3J0ZWQgb24gdGhlIHNlcnZlci5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yIFRoZSBFYXN5TURFIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSB1cGxvYWRlZCBpbWFnZVxuICovXG5mdW5jdGlvbiBhZnRlckltYWdlVXBsb2FkZWQoZWRpdG9yLCB1cmwpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIHZhciBpbWFnZU5hbWUgPSB1cmwuc3Vic3RyKHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgdmFyIGV4dCA9IGltYWdlTmFtZS5zdWJzdHJpbmcoaW1hZ2VOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENoZWNrIGlmIG1lZGlhIGlzIGFuIGltYWdlXG4gICAgaWYgKFsncG5nJywgJ2pwZycsICdqcGVnJywgJ2dpZicsICdzdmcnLCAnYXBuZycsICdhdmlmJywgJ3dlYnAnXS5pbmNsdWRlcyhleHQpKSB7XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LmltYWdlLCBvcHRpb25zLmluc2VydFRleHRzLnVwbG9hZGVkSW1hZ2UsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRfbGluayA9IG9wdGlvbnMuaW5zZXJ0VGV4dHMubGluaztcbiAgICAgICAgdGV4dF9saW5rWzBdID0gJ1snICsgaW1hZ2VOYW1lO1xuICAgICAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgc3RhdC5saW5rLCB0ZXh0X2xpbmssIHVybCk7XG4gICAgfVxuXG4gICAgLy8gc2hvdyB1cGxvYWRlZCBpbWFnZSBmaWxlbmFtZSBmb3IgMTAwMG1zXG4gICAgZWRpdG9yLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgZWRpdG9yLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYk9uVXBsb2FkZWQucmVwbGFjZSgnI2ltYWdlX25hbWUjJywgaW1hZ2VOYW1lKSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVkaXRvci51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIGVkaXRvci5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICB9LCAxMDAwKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGRyYXdpbmcgYSB0YWJsZS5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIGRyYXdUYWJsZShlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LnRhYmxlLCBvcHRpb25zLmluc2VydFRleHRzLnRhYmxlKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGRyYXdpbmcgYSBob3Jpem9udGFsIHJ1bGUuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBkcmF3SG9yaXpvbnRhbFJ1bGUoZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgc3RhdC5pbWFnZSwgb3B0aW9ucy5pbnNlcnRUZXh0cy5ob3Jpem9udGFsUnVsZSk7XG59XG5cblxuLyoqXG4gKiBVbmRvIGFjdGlvbi5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHVuZG8oZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgY20udW5kbygpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cblxuLyoqXG4gKiBSZWRvIGFjdGlvbi5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZG8oZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgY20ucmVkbygpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cblxuLyoqXG4gKiBUb2dnbGUgc2lkZSBieSBzaWRlIHByZXZpZXdcbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVNpZGVCeVNpZGUoZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5uZXh0U2libGluZztcbiAgICB2YXIgdG9vbGJhckJ1dHRvbiA9IGVkaXRvci50b29sYmFyRWxlbWVudHMgJiYgZWRpdG9yLnRvb2xiYXJFbGVtZW50c1snc2lkZS1ieS1zaWRlJ107XG4gICAgdmFyIHVzZVNpZGVCeVNpZGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgdmFyIGVhc3lNREVDb250YWluZXIgPSB3cmFwcGVyLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJykpIHtcbiAgICAgICAgaWYgKGVkaXRvci5vcHRpb25zLnNpZGVCeVNpZGVGdWxsc2NyZWVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gaWYgc2lkZS1ieS1zaWRlIG5vdC1mdWxsc2NyZWVuIG9rLCByZW1vdmUgY2xhc3NlcyB3aGVuIGhpZGluZyBzaWRlXG4gICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3NpZGVkLS1uby1mdWxsc2NyZWVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlldy5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpO1xuICAgICAgICBpZiAodG9vbGJhckJ1dHRvbikgdG9vbGJhckJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdDb2RlTWlycm9yLXNpZGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgcHJldmlldyBidXR0b24gaXMgY2xpY2tlZCBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gICAgICAgIC8vIGdpdmUgc29tZSB0aW1lIGZvciB0aGUgdHJhbnNpdGlvbiBmcm9tIGVkaXRvci5jc3MgdG8gZmlyZSBhbmQgdGhlIHZpZXcgdG8gc2xpZGUgZnJvbSByaWdodCB0byBsZWZ0LFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGp1c3QgYXBwZWFyaW5nLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY20uZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMuc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNpZGUtYnktc2lkZSBub3QtZnVsbHNjcmVlbiBvaywgYWRkIGNsYXNzZXMgd2hlbiBub3QgZnVsbHNjcmVlbiBhbmQgc2hvd2luZyBzaWRlXG4gICAgICAgICAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2lkZWQtLW5vLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVGdWxsU2NyZWVuKGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpO1xuICAgICAgICB9LCAxKTtcbiAgICAgICAgaWYgKHRvb2xiYXJCdXR0b24pIHRvb2xiYXJCdXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnQ29kZU1pcnJvci1zaWRlZCcpO1xuICAgICAgICB1c2VTaWRlQnlTaWRlTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEhpZGUgbm9ybWFsIHByZXZpZXcgaWYgYWN0aXZlXG4gICAgdmFyIHByZXZpZXdOb3JtYWwgPSB3cmFwcGVyLmxhc3RDaGlsZDtcbiAgICBpZiAocHJldmlld05vcm1hbC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKSB7XG4gICAgICAgIHByZXZpZXdOb3JtYWwuY2xhc3NMaXN0LnJlbW92ZSgnZWRpdG9yLXByZXZpZXctYWN0aXZlJyk7XG4gICAgICAgIHZhciB0b29sYmFyID0gZWRpdG9yLnRvb2xiYXJFbGVtZW50cy5wcmV2aWV3O1xuICAgICAgICB2YXIgdG9vbGJhcl9kaXYgPSBlZGl0b3IudG9vbGJhcl9kaXY7XG4gICAgICAgIHRvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIHRvb2xiYXJfZGl2LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkLWZvci1wcmV2aWV3Jyk7XG4gICAgfVxuXG4gICAgdmFyIHNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZWRpdG9yLm9wdGlvbnMucHJldmlld1JlbmRlcihlZGl0b3IudmFsdWUoKSwgcHJldmlldyk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICghY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGNtLnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbiA9IHNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodXNlU2lkZUJ5U2lkZUxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGVkaXRvci5vcHRpb25zLnByZXZpZXdSZW5kZXIoZWRpdG9yLnZhbHVlKCksIHByZXZpZXcpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldmlldy5pbm5lckhUTUwgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbS5vbigndXBkYXRlJywgY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjbS5vZmYoJ3VwZGF0ZScsIGNtLnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCB0byBmaXggc2VsZWN0aW9uIGJlaW5nIG9mZiAoIzMwOSlcbiAgICBjbS5yZWZyZXNoKCk7XG59XG5cblxuLyoqXG4gKiBQcmV2aWV3IGFjdGlvbi5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVByZXZpZXcoZWRpdG9yKSB7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciB0b29sYmFyX2RpdiA9IGVkaXRvci50b29sYmFyX2RpdjtcbiAgICB2YXIgdG9vbGJhciA9IGVkaXRvci5vcHRpb25zLnRvb2xiYXIgPyBlZGl0b3IudG9vbGJhckVsZW1lbnRzLnByZXZpZXcgOiBmYWxzZTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubGFzdENoaWxkO1xuXG4gICAgLy8gVHVybiBvZmYgc2lkZSBieSBzaWRlIGlmIG5lZWRlZFxuICAgIHZhciBzaWRlYnlzaWRlID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5uZXh0U2libGluZztcbiAgICBpZiAoc2lkZWJ5c2lkZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJykpXG4gICAgICAgIHRvZ2dsZVNpZGVCeVNpZGUoZWRpdG9yKTtcblxuICAgIGlmICghcHJldmlldyB8fCAhcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWZ1bGwnKSkge1xuXG4gICAgICAgIHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5jbGFzc05hbWUgPSAnZWRpdG9yLXByZXZpZXctZnVsbCc7XG5cbiAgICAgICAgaWYgKGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcykge1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3Q2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpIHtcbiAgICAgICAgcHJldmlldy5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgaWYgKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICB0b29sYmFyX2Rpdi5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZC1mb3ItcHJldmlldycpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgcHJldmlldyBidXR0b24gaXMgY2xpY2tlZCBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gICAgICAgIC8vIGdpdmUgc29tZSB0aW1lIGZvciB0aGUgdHJhbnNpdGlvbiBmcm9tIGVkaXRvci5jc3MgdG8gZmlyZSBhbmQgdGhlIHZpZXcgdG8gc2xpZGUgZnJvbSByaWdodCB0byBsZWZ0LFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGp1c3QgYXBwZWFyaW5nLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZCgnZWRpdG9yLXByZXZpZXctYWN0aXZlJyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRvb2xiYXJfZGl2LmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkLWZvci1wcmV2aWV3Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlld19yZXN1bHQgPSBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGVkaXRvci52YWx1ZSgpLCBwcmV2aWV3KTtcbiAgICBpZiAocHJldmlld19yZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgcHJldmlldy5pbm5lckhUTUwgPSBwcmV2aWV3X3Jlc3VsdDtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gX3JlcGxhY2VTZWxlY3Rpb24oY20sIGFjdGl2ZSwgc3RhcnRFbmQsIHVybCkge1xuICAgIGlmIChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgc3RhcnQgPSBzdGFydEVuZFswXTtcbiAgICB2YXIgZW5kID0gc3RhcnRFbmRbMV07XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSB7fSxcbiAgICAgICAgZW5kUG9pbnQgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKHN0YXJ0UG9pbnQsIGNtLmdldEN1cnNvcignc3RhcnQnKSk7XG4gICAgT2JqZWN0LmFzc2lnbihlbmRQb2ludCwgY20uZ2V0Q3Vyc29yKCdlbmQnKSk7XG4gICAgaWYgKHVybCkge1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoJyN1cmwjJywgdXJsKTsgIC8vIHVybCBpcyBpbiBzdGFydCBmb3IgdXBsb2FkLWltYWdlXG4gICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKCcjdXJsIycsIHVybCk7XG4gICAgfVxuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldExpbmUoc3RhcnRQb2ludC5saW5lKTtcbiAgICAgICAgc3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0UG9pbnQuY2gpO1xuICAgICAgICBlbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0UG9pbnQuY2gpO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2Uoc3RhcnQgKyBlbmQsIHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0UG9pbnQubGluZSxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oc3RhcnQgKyB0ZXh0ICsgZW5kKTtcblxuICAgICAgICBzdGFydFBvaW50LmNoICs9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQgIT09IGVuZFBvaW50KSB7XG4gICAgICAgICAgICBlbmRQb2ludC5jaCArPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50KTtcbiAgICBjbS5mb2N1cygpO1xufVxuXG5cbmZ1bmN0aW9uIF90b2dnbGVIZWFkaW5nKGNtLCBkaXJlY3Rpb24sIHNpemUpIHtcbiAgICBpZiAoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRQb2ludC5saW5lOyBpIDw9IGVuZFBvaW50LmxpbmU7IGkrKykge1xuICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShpKTtcbiAgICAgICAgICAgIHZhciBjdXJySGVhZGluZ0xldmVsID0gdGV4dC5zZWFyY2goL1teI10vKTtcblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09ICdiaWdnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMjIyMjIyAnICsgdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIyAnICsgdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyckhlYWRpbmdMZXZlbCA9PSA2ICYmIGRpcmVjdGlvbiA9PSAnc21hbGxlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyckhlYWRpbmdMZXZlbCA9PSAxICYmIGRpcmVjdGlvbiA9PSAnYmlnZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYmlnZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjJyArIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJySGVhZGluZ0xldmVsIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjJy5yZXBlYXQoc2l6ZSkgKyAnICcgKyB0ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyckhlYWRpbmdMZXZlbCA9PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cihjdXJySGVhZGluZ0xldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjJy5yZXBlYXQoc2l6ZSkgKyAnICcgKyB0ZXh0LnN1YnN0cihjdXJySGVhZGluZ0xldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwge1xuICAgICAgICAgICAgICAgIGxpbmU6IGksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoaSk7XG4gICAgfVxuICAgIGNtLmZvY3VzKCk7XG59XG5cblxuZnVuY3Rpb24gX3RvZ2dsZUxpbmUoY20sIG5hbWUsIGxpc3RzdHlsZSkge1xuICAgIGlmIChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgbGlzdFJlZ2V4cCA9IC9eKFxccyopKFxcKnwtfFxcK3xcXGQqXFwuKShcXHMrKS87XG4gICAgdmFyIHdoaXRlc3BhY2VzUmVnZXhwID0gL15cXHMqLztcblxuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBzdGFydFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBlbmRQb2ludCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgdmFyIHJlcGwgPSB7XG4gICAgICAgICdxdW90ZSc6IC9eKFxccyopPlxccysvLFxuICAgICAgICAndW5vcmRlcmVkLWxpc3QnOiBsaXN0UmVnZXhwLFxuICAgICAgICAnb3JkZXJlZC1saXN0JzogbGlzdFJlZ2V4cCxcbiAgICB9O1xuXG4gICAgdmFyIF9nZXRDaGFyID0gZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgICAgICdxdW90ZSc6ICc+JyxcbiAgICAgICAgICAgICd1bm9yZGVyZWQtbGlzdCc6IGxpc3RzdHlsZSxcbiAgICAgICAgICAgICdvcmRlcmVkLWxpc3QnOiAnJSVpLicsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1hcFtuYW1lXS5yZXBsYWNlKCclJWknLCBpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9jaGVja0NoYXIgPSBmdW5jdGlvbiAobmFtZSwgY2hhcikge1xuICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgJ3F1b3RlJzogJz4nLFxuICAgICAgICAgICAgJ3Vub3JkZXJlZC1saXN0JzogJ1xcXFwnICsgbGlzdHN0eWxlLFxuICAgICAgICAgICAgJ29yZGVyZWQtbGlzdCc6ICdcXFxcZCsuJyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ0ID0gbmV3IFJlZ0V4cChtYXBbbmFtZV0pO1xuXG4gICAgICAgIHJldHVybiBjaGFyICYmIHJ0LnRlc3QoY2hhcik7XG4gICAgfTtcblxuICAgIHZhciBfdG9nZ2xlID0gZnVuY3Rpb24gKG5hbWUsIHRleHQsIHVudG9nZ2xlT25seSkge1xuICAgICAgICB2YXIgYXJyID0gbGlzdFJlZ2V4cC5leGVjKHRleHQpO1xuICAgICAgICB2YXIgY2hhciA9IF9nZXRDaGFyKG5hbWUsIGxpbmUpO1xuICAgICAgICBpZiAoYXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoX2NoZWNrQ2hhcihuYW1lLCBhcnJbMl0pKSB7XG4gICAgICAgICAgICAgICAgY2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGFyclsxXSArIGNoYXIgKyBhcnJbM10gKyB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZXNSZWdleHAsICcnKS5yZXBsYWNlKHJlcGxbbmFtZV0sICckMScpO1xuICAgICAgICB9IGVsc2UgaWYgKHVudG9nZ2xlT25seSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGV4dCA9IGNoYXIgKyAnICcgKyB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICB2YXIgbGluZSA9IDE7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0UG9pbnQubGluZTsgaSA8PSBlbmRQb2ludC5saW5lOyBpKyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGNtLmdldExpbmUoaSk7XG4gICAgICAgICAgICBpZiAoc3RhdFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVwbFtuYW1lXSwgJyQxJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRvZ2dsaW5nIHVub3JkZXJlZC1saXN0IGZvcm1hdHRpbmcsIGNoZWNrIGlmIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICAvLyBpcyBwYXJ0IG9mIGFuIG9yZGVyZWQtbGlzdCwgYW5kIGlmIHNvLCB1bnRvZ2dsZSB0aGF0IGZpcnN0LlxuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Jb25hcnUvZWFzeS1tYXJrZG93bi1lZGl0b3IvaXNzdWVzLzkyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ3Vub3JkZXJlZC1saXN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX3RvZ2dsZSgnb3JkZXJlZC1saXN0JywgdGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSBfdG9nZ2xlKG5hbWUsIHRleHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwge1xuICAgICAgICAgICAgICAgIGxpbmU6IGksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoaSk7XG4gICAgfVxuICAgIGNtLmZvY3VzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqIEBwYXJhbSB7J2xpbmsnIHwgJ2ltYWdlJ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0RW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKi9cbmZ1bmN0aW9uIF90b2dnbGVMaW5rKGVkaXRvciwgdHlwZSwgc3RhcnRFbmQsIHVybCkge1xuICAgIGlmICghZWRpdG9yLmNvZGVtaXJyb3IgfHwgZWRpdG9yLmlzUHJldmlld0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgYWN0aXZlID0gc3RhdFt0eXBlXTtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICBfcmVwbGFjZVNlbGVjdGlvbihjbSwgYWN0aXZlLCBzdGFydEVuZCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBlbmRQb2ludCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKHN0YXJ0UG9pbnQubGluZSk7XG4gICAgdmFyIHN0YXJ0ID0gdGV4dC5zbGljZSgwLCBzdGFydFBvaW50LmNoKTtcbiAgICB2YXIgZW5kID0gdGV4dC5zbGljZShzdGFydFBvaW50LmNoKTtcblxuICAgIGlmICh0eXBlID09ICdsaW5rJykge1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyguKilbXiFdXFxbLywgJyQxJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdpbWFnZScpIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8oLiopIVxcWyQvLCAnJDEnKTtcbiAgICB9XG4gICAgZW5kID0gZW5kLnJlcGxhY2UoL11cXCguKj9cXCkvLCAnJyk7XG5cbiAgICBjbS5yZXBsYWNlUmFuZ2Uoc3RhcnQgKyBlbmQsIHtcbiAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICBjaDogMCxcbiAgICB9LCB7XG4gICAgICAgIGxpbmU6IHN0YXJ0UG9pbnQubGluZSxcbiAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgIH0pO1xuXG4gICAgc3RhcnRQb2ludC5jaCAtPSBzdGFydEVuZFswXS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0UG9pbnQgIT09IGVuZFBvaW50KSB7XG4gICAgICAgIGVuZFBvaW50LmNoIC09IHN0YXJ0RW5kWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50KTtcbiAgICBjbS5mb2N1cygpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIF90b2dnbGVCbG9jayhlZGl0b3IsIHR5cGUsIHN0YXJ0X2NoYXJzLCBlbmRfY2hhcnMpIHtcbiAgICBpZiAoIWVkaXRvci5jb2RlbWlycm9yIHx8IGVkaXRvci5pc1ByZXZpZXdBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5kX2NoYXJzID0gKHR5cGVvZiBlbmRfY2hhcnMgPT09ICd1bmRlZmluZWQnKSA/IHN0YXJ0X2NoYXJzIDogZW5kX2NoYXJzO1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuXG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRfY2hhcnM7XG4gICAgdmFyIGVuZCA9IGVuZF9jaGFycztcblxuICAgIHZhciBzdGFydFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBlbmRQb2ludCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG5cbiAgICBpZiAoc3RhdFt0eXBlXSkge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0TGluZShzdGFydFBvaW50LmxpbmUpO1xuICAgICAgICBzdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGVuZCA9IHRleHQuc2xpY2Uoc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGlmICh0eXBlID09ICdib2xkJykge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8oXFwqXFwqfF9fKSg/IVtcXHNcXFNdKihcXCpcXCp8X18pKS8sICcnKTtcbiAgICAgICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC8oXFwqXFwqfF9fKS8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyhcXCp8XykoPyFbXFxzXFxTXSooXFwqfF8pKS8sICcnKTtcbiAgICAgICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC8oXFwqfF8pLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyhcXCpcXCp8fn4pKD8hW1xcc1xcU10qKFxcKlxcKnx+fikpLywgJycpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoLyhcXCpcXCp8fn4pLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0UG9pbnQubGluZSxcbiAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JvbGQnIHx8IHR5cGUgPT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICBzdGFydFBvaW50LmNoIC09IDI7XG4gICAgICAgICAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBlbmRQb2ludC5jaCAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQuY2ggLT0gMTtcbiAgICAgICAgICAgIGlmIChzdGFydFBvaW50ICE9PSBlbmRQb2ludCkge1xuICAgICAgICAgICAgICAgIGVuZFBvaW50LmNoIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdib2xkJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJyoqJykuam9pbignJyk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnX18nKS5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnKicpLmpvaW4oJycpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJ18nKS5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpa2V0aHJvdWdoJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJ35+Jykuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzdGFydCArIHRleHQgKyBlbmQpO1xuXG4gICAgICAgIHN0YXJ0UG9pbnQuY2ggKz0gc3RhcnRfY2hhcnMubGVuZ3RoO1xuICAgICAgICBlbmRQb2ludC5jaCA9IHN0YXJ0UG9pbnQuY2ggKyB0ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBjbS5zZXRTZWxlY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cbmZ1bmN0aW9uIF9jbGVhbkJsb2NrKGNtKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBzdGFydFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgIHZhciBlbmRQb2ludCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgdmFyIHRleHQ7XG5cbiAgICBmb3IgKHZhciBsaW5lID0gc3RhcnRQb2ludC5saW5lOyBsaW5lIDw9IGVuZFBvaW50LmxpbmU7IGxpbmUrKykge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlsgXSooWyMgXSt8XFwqfC18Wz4gXSt8WzAtOV0rKC58XFwpKSlbIF0qLywgJycpO1xuXG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIGJ5dGVzIHRvIGEgaHVtYW4tcmVhZGFibGUgZmlsZSBzaXplLiBJZiB5b3UgZGVzaXJlXG4gKiB0byBhZGQgYSBzcGFjZSBiZXR3ZWVuIHRoZSB2YWx1ZSBhbmQgdGhlIHVuaXQsIHlvdSBuZWVkIHRvIGFkZCB0aGlzIHNwYWNlXG4gKiB0byB0aGUgZ2l2ZW4gdW5pdHMuXG4gKiBAcGFyYW0gYnl0ZXMge251bWJlcn0gQSBudW1iZXIgb2YgYnl0ZXMsIGFzIGludGVnZXIuIEV4OiA0MjExMzdcbiAqIEBwYXJhbSB1bml0cyB7bnVtYmVyW119IEFuIGFycmF5IG9mIGh1bWFuLXJlYWRhYmxlIHVuaXRzLCBpZS4gWycgQicsICcgSycsICcgTUInXVxuICogQHJldHVybnMgc3RyaW5nIEEgaHVtYW4tcmVhZGFibGUgZmlsZSBzaXplLiBFeDogJzQxMiBLQidcbiAqL1xuZnVuY3Rpb24gaHVtYW5GaWxlU2l6ZShieXRlcywgdW5pdHMpIHtcbiAgICBpZiAoTWF0aC5hYnMoYnl0ZXMpIDwgMTAyNCkge1xuICAgICAgICByZXR1cm4gJycgKyBieXRlcyArIHVuaXRzWzBdO1xuICAgIH1cbiAgICB2YXIgdSA9IDA7XG4gICAgZG8ge1xuICAgICAgICBieXRlcyAvPSAxMDI0O1xuICAgICAgICArK3U7XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoYnl0ZXMpID49IDEwMjQgJiYgdSA8IHVuaXRzLmxlbmd0aCk7XG4gICAgcmV0dXJuICcnICsgYnl0ZXMudG9GaXhlZCgxKSArIHVuaXRzW3VdO1xufVxuXG4vLyBNZXJnZSB0aGUgcHJvcGVydGllcyBvZiBvbmUgb2JqZWN0IGludG8gYW5vdGhlci5cbmZ1bmN0aW9uIF9tZXJnZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtwcm9wZXJ0eV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldLmNvbmNhdCh0YXJnZXRbcHJvcGVydHldIGluc3RhbmNlb2YgQXJyYXkgPyB0YXJnZXRbcHJvcGVydHldIDogW10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gX21lcmdlUHJvcGVydGllcyh0YXJnZXRbcHJvcGVydHldIHx8IHt9LCBzb3VyY2VbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBNZXJnZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG9iamVjdHMgaW50byBvbmUuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0ID0gX21lcmdlUHJvcGVydGllcyh0YXJnZXQsIGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyogVGhlIHJpZ2h0IHdvcmQgY291bnQgaW4gcmVzcGVjdCBmb3IgQ0pLLiAqL1xuZnVuY3Rpb24gd29yZENvdW50KGRhdGEpIHtcbiAgICB2YXIgcGF0dGVybiA9IC9bYS16QS1aMC05X1xcdTAwQTAtXFx1MDJBRlxcdTAzOTItXFx1MDNjOVxcdTA0MTAtXFx1MDRGOV0rfFtcXHU0RTAwLVxcdTlGRkZcXHUzNDAwLVxcdTRkYmZcXHVmOTAwLVxcdWZhZmZcXHUzMDQwLVxcdTMwOWZcXHVhYzAwLVxcdWQ3YWZdKy9nO1xuICAgIHZhciBtID0gZGF0YS5tYXRjaChwYXR0ZXJuKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGlmIChtID09PSBudWxsKSByZXR1cm4gY291bnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtW2ldLmNoYXJDb2RlQXQoMCkgPj0gMHg0RTAwKSB7XG4gICAgICAgICAgICBjb3VudCArPSBtW2ldLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG52YXIgaWNvbkNsYXNzTWFwID0ge1xuICAgICdib2xkJzogJ2ZhIGZhLWJvbGQnLFxuICAgICdpdGFsaWMnOiAnZmEgZmEtaXRhbGljJyxcbiAgICAnc3RyaWtldGhyb3VnaCc6ICdmYSBmYS1zdHJpa2V0aHJvdWdoJyxcbiAgICAnaGVhZGluZyc6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZycsXG4gICAgJ2hlYWRpbmctc21hbGxlcic6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItc21hbGxlcicsXG4gICAgJ2hlYWRpbmctYmlnZ2VyJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci1iaWdnZXInLFxuICAgICdoZWFkaW5nLTEnOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLTEnLFxuICAgICdoZWFkaW5nLTInOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLTInLFxuICAgICdoZWFkaW5nLTMnOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLTMnLFxuICAgICdjb2RlJzogJ2ZhIGZhLWNvZGUnLFxuICAgICdxdW90ZSc6ICdmYSBmYS1xdW90ZS1sZWZ0JyxcbiAgICAnb3JkZXJlZC1saXN0JzogJ2ZhIGZhLWxpc3Qtb2wnLFxuICAgICd1bm9yZGVyZWQtbGlzdCc6ICdmYSBmYS1saXN0LXVsJyxcbiAgICAnY2xlYW4tYmxvY2snOiAnZmEgZmEtZXJhc2VyJyxcbiAgICAnbGluayc6ICdmYSBmYS1saW5rJyxcbiAgICAnaW1hZ2UnOiAnZmEgZmEtaW1hZ2UnLFxuICAgICd1cGxvYWQtaW1hZ2UnOiAnZmEgZmEtaW1hZ2UnLFxuICAgICd0YWJsZSc6ICdmYSBmYS10YWJsZScsXG4gICAgJ2hvcml6b250YWwtcnVsZSc6ICdmYSBmYS1taW51cycsXG4gICAgJ3ByZXZpZXcnOiAnZmEgZmEtZXllJyxcbiAgICAnc2lkZS1ieS1zaWRlJzogJ2ZhIGZhLWNvbHVtbnMnLFxuICAgICdmdWxsc2NyZWVuJzogJ2ZhIGZhLWFycm93cy1hbHQnLFxuICAgICdndWlkZSc6ICdmYSBmYS1xdWVzdGlvbi1jaXJjbGUnLFxuICAgICd1bmRvJzogJ2ZhIGZhLXVuZG8nLFxuICAgICdyZWRvJzogJ2ZhIGZhLXJlcGVhdCBmYS1yZWRvJyxcbn07XG5cbnZhciB0b29sYmFyQnVpbHRJbkJ1dHRvbnMgPSB7XG4gICAgJ2JvbGQnOiB7XG4gICAgICAgIG5hbWU6ICdib2xkJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVCb2xkLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnYm9sZCddLFxuICAgICAgICB0aXRsZTogJ0JvbGQnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ2l0YWxpYyc6IHtcbiAgICAgICAgbmFtZTogJ2l0YWxpYycsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSXRhbGljLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaXRhbGljJ10sXG4gICAgICAgIHRpdGxlOiAnSXRhbGljJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdzdHJpa2V0aHJvdWdoJzoge1xuICAgICAgICBuYW1lOiAnc3RyaWtldGhyb3VnaCcsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlU3RyaWtldGhyb3VnaCxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3N0cmlrZXRocm91Z2gnXSxcbiAgICAgICAgdGl0bGU6ICdTdHJpa2V0aHJvdWdoJyxcbiAgICB9LFxuICAgICdoZWFkaW5nJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZ1NtYWxsZXIsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nJ10sXG4gICAgICAgIHRpdGxlOiAnSGVhZGluZycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnaGVhZGluZy1zbWFsbGVyJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy1zbWFsbGVyJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nU21hbGxlcixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctc21hbGxlciddLFxuICAgICAgICB0aXRsZTogJ1NtYWxsZXIgSGVhZGluZycsXG4gICAgfSxcbiAgICAnaGVhZGluZy1iaWdnZXInOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLWJpZ2dlcicsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZ0JpZ2dlcixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctYmlnZ2VyJ10sXG4gICAgICAgIHRpdGxlOiAnQmlnZ2VyIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctMSc6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctMScsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZzEsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLTEnXSxcbiAgICAgICAgdGl0bGU6ICdCaWcgSGVhZGluZycsXG4gICAgfSxcbiAgICAnaGVhZGluZy0yJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy0yJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nMixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctMiddLFxuICAgICAgICB0aXRsZTogJ01lZGl1bSBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLTMnOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLTMnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmczLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy0zJ10sXG4gICAgICAgIHRpdGxlOiAnU21hbGwgSGVhZGluZycsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTEnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItMScsXG4gICAgfSxcbiAgICAnY29kZSc6IHtcbiAgICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUNvZGVCbG9jayxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2NvZGUnXSxcbiAgICAgICAgdGl0bGU6ICdDb2RlJyxcbiAgICB9LFxuICAgICdxdW90ZSc6IHtcbiAgICAgICAgbmFtZTogJ3F1b3RlJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVCbG9ja3F1b3RlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsncXVvdGUnXSxcbiAgICAgICAgdGl0bGU6ICdRdW90ZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAndW5vcmRlcmVkLWxpc3QnOiB7XG4gICAgICAgIG5hbWU6ICd1bm9yZGVyZWQtbGlzdCcsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlVW5vcmRlcmVkTGlzdCxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3Vub3JkZXJlZC1saXN0J10sXG4gICAgICAgIHRpdGxlOiAnR2VuZXJpYyBMaXN0JyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdvcmRlcmVkLWxpc3QnOiB7XG4gICAgICAgIG5hbWU6ICdvcmRlcmVkLWxpc3QnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZU9yZGVyZWRMaXN0LFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnb3JkZXJlZC1saXN0J10sXG4gICAgICAgIHRpdGxlOiAnTnVtYmVyZWQgTGlzdCcsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnY2xlYW4tYmxvY2snOiB7XG4gICAgICAgIG5hbWU6ICdjbGVhbi1ibG9jaycsXG4gICAgICAgIGFjdGlvbjogY2xlYW5CbG9jayxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2NsZWFuLWJsb2NrJ10sXG4gICAgICAgIHRpdGxlOiAnQ2xlYW4gYmxvY2snLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci0yJzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTInLFxuICAgIH0sXG4gICAgJ2xpbmsnOiB7XG4gICAgICAgIG5hbWU6ICdsaW5rJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3TGluayxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2xpbmsnXSxcbiAgICAgICAgdGl0bGU6ICdDcmVhdGUgTGluaycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnaW1hZ2UnOiB7XG4gICAgICAgIG5hbWU6ICdpbWFnZScsXG4gICAgICAgIGFjdGlvbjogZHJhd0ltYWdlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaW1hZ2UnXSxcbiAgICAgICAgdGl0bGU6ICdJbnNlcnQgSW1hZ2UnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3VwbG9hZC1pbWFnZSc6IHtcbiAgICAgICAgbmFtZTogJ3VwbG9hZC1pbWFnZScsXG4gICAgICAgIGFjdGlvbjogZHJhd1VwbG9hZGVkSW1hZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWyd1cGxvYWQtaW1hZ2UnXSxcbiAgICAgICAgdGl0bGU6ICdJbXBvcnQgYW4gaW1hZ2UnLFxuICAgIH0sXG4gICAgJ3RhYmxlJzoge1xuICAgICAgICBuYW1lOiAndGFibGUnLFxuICAgICAgICBhY3Rpb246IGRyYXdUYWJsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3RhYmxlJ10sXG4gICAgICAgIHRpdGxlOiAnSW5zZXJ0IFRhYmxlJyxcbiAgICB9LFxuICAgICdob3Jpem9udGFsLXJ1bGUnOiB7XG4gICAgICAgIG5hbWU6ICdob3Jpem9udGFsLXJ1bGUnLFxuICAgICAgICBhY3Rpb246IGRyYXdIb3Jpem9udGFsUnVsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hvcml6b250YWwtcnVsZSddLFxuICAgICAgICB0aXRsZTogJ0luc2VydCBIb3Jpem9udGFsIExpbmUnLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci0zJzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTMnLFxuICAgIH0sXG4gICAgJ3ByZXZpZXcnOiB7XG4gICAgICAgIG5hbWU6ICdwcmV2aWV3JyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVQcmV2aWV3LFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsncHJldmlldyddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVG9nZ2xlIFByZXZpZXcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3NpZGUtYnktc2lkZSc6IHtcbiAgICAgICAgbmFtZTogJ3NpZGUtYnktc2lkZScsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlU2lkZUJ5U2lkZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3NpZGUtYnktc2lkZSddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIG5vTW9iaWxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1RvZ2dsZSBTaWRlIGJ5IFNpZGUnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ2Z1bGxzY3JlZW4nOiB7XG4gICAgICAgIG5hbWU6ICdmdWxsc2NyZWVuJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVGdWxsU2NyZWVuLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnZnVsbHNjcmVlbiddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIG5vTW9iaWxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1RvZ2dsZSBGdWxsc2NyZWVuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItNCc6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci00JyxcbiAgICB9LFxuICAgICdndWlkZSc6IHtcbiAgICAgICAgbmFtZTogJ2d1aWRlJyxcbiAgICAgICAgYWN0aW9uOiAnaHR0cHM6Ly93d3cubWFya2Rvd25ndWlkZS5vcmcvYmFzaWMtc3ludGF4LycsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydndWlkZSddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnTWFya2Rvd24gR3VpZGUnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci01Jzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTUnLFxuICAgIH0sXG4gICAgJ3VuZG8nOiB7XG4gICAgICAgIG5hbWU6ICd1bmRvJyxcbiAgICAgICAgYWN0aW9uOiB1bmRvLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndW5kbyddLFxuICAgICAgICBub0Rpc2FibGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVW5kbycsXG4gICAgfSxcbiAgICAncmVkbyc6IHtcbiAgICAgICAgbmFtZTogJ3JlZG8nLFxuICAgICAgICBhY3Rpb246IHJlZG8sXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydyZWRvJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdSZWRvJyxcbiAgICB9LFxufTtcblxudmFyIGluc2VydFRleHRzID0ge1xuICAgIGxpbms6IFsnWycsICddKCN1cmwjKSddLFxuICAgIGltYWdlOiBbJyFbJywgJ10oI3VybCMpJ10sXG4gICAgdXBsb2FkZWRJbWFnZTogWychW10oI3VybCMpJywgJyddLFxuICAgIC8vIHVwbG9hZGVkSW1hZ2U6IFsnIVtdKCN1cmwjKVxcbicsICcnXSwgLy8gVE9ETzogTmV3IGxpbmUgaW5zZXJ0aW9uIGRvZXNuJ3Qgd29yayBoZXJlLlxuICAgIHRhYmxlOiBbJycsICdcXG5cXG58IENvbHVtbiAxIHwgQ29sdW1uIDIgfCBDb2x1bW4gMyB8XFxufCAtLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0gfFxcbnwgVGV4dCAgICAgfCBUZXh0ICAgICB8IFRleHQgICAgIHxcXG5cXG4nXSxcbiAgICBob3Jpem9udGFsUnVsZTogWycnLCAnXFxuXFxuLS0tLS1cXG5cXG4nXSxcbn07XG5cbnZhciBwcm9tcHRUZXh0cyA9IHtcbiAgICBsaW5rOiAnVVJMIGZvciB0aGUgbGluazonLFxuICAgIGltYWdlOiAnVVJMIG9mIHRoZSBpbWFnZTonLFxufTtcblxudmFyIHRpbWVGb3JtYXQgPSB7XG4gICAgbG9jYWxlOiAnZW4tVVMnLFxuICAgIGZvcm1hdDoge1xuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIH0sXG59O1xuXG52YXIgYmxvY2tTdHlsZXMgPSB7XG4gICAgJ2JvbGQnOiAnKionLFxuICAgICdjb2RlJzogJ2BgYCcsXG4gICAgJ2l0YWxpYyc6ICcqJyxcbn07XG5cbi8qKlxuICogVGV4dHMgZGlzcGxheWVkIHRvIHRoZSB1c2VyIChtYWlubHkgb24gdGhlIHN0YXR1cyBiYXIpIGZvciB0aGUgaW1wb3J0IGltYWdlXG4gKiBmZWF0dXJlLiBDYW4gYmUgdXNlZCBmb3IgY3VzdG9taXphdGlvbiBvciBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiAqL1xudmFyIGltYWdlVGV4dHMgPSB7XG4gICAgc2JJbml0OiAnQXR0YWNoIGZpbGVzIGJ5IGRyYWcgYW5kIGRyb3BwaW5nIG9yIHBhc3RpbmcgZnJvbSBjbGlwYm9hcmQuJyxcbiAgICBzYk9uRHJhZ0VudGVyOiAnRHJvcCBpbWFnZSB0byB1cGxvYWQgaXQuJyxcbiAgICBzYk9uRHJvcDogJ1VwbG9hZGluZyBpbWFnZSAjaW1hZ2VzX25hbWVzIy4uLicsXG4gICAgc2JQcm9ncmVzczogJ1VwbG9hZGluZyAjZmlsZV9uYW1lIzogI3Byb2dyZXNzIyUnLFxuICAgIHNiT25VcGxvYWRlZDogJ1VwbG9hZGVkICNpbWFnZV9uYW1lIycsXG4gICAgc2l6ZVVuaXRzOiAnIEIsIEtCLCBNQicsXG59O1xuXG4vKipcbiAqIEVycm9ycyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIsIHVzaW5nIHRoZSBgZXJyb3JDYWxsYmFja2Agb3B0aW9uLiBDYW4gYmUgdXNlZCBmb3JcbiAqIGN1c3RvbWl6YXRpb24gb3IgaW50ZXJuYXRpb25hbGl6YXRpb24uXG4gKi9cbnZhciBlcnJvck1lc3NhZ2VzID0ge1xuICAgIG5vRmlsZUdpdmVuOiAnWW91IG11c3Qgc2VsZWN0IGEgZmlsZS4nLFxuICAgIHR5cGVOb3RBbGxvd2VkOiAnVGhpcyBpbWFnZSB0eXBlIGlzIG5vdCBhbGxvd2VkLicsXG4gICAgZmlsZVRvb0xhcmdlOiAnSW1hZ2UgI2ltYWdlX25hbWUjIGlzIHRvbyBiaWcgKCNpbWFnZV9zaXplIykuXFxuJyArXG4gICAgICAgICdNYXhpbXVtIGZpbGUgc2l6ZSBpcyAjaW1hZ2VfbWF4X3NpemUjLicsXG4gICAgaW1wb3J0RXJyb3I6ICdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGVuIHVwbG9hZGluZyB0aGUgaW1hZ2UgI2ltYWdlX25hbWUjLicsXG59O1xuXG4vKipcbiAqIEludGVyZmFjZSBvZiBFYXN5TURFLlxuICovXG5mdW5jdGlvbiBFYXN5TURFKG9wdGlvbnMpIHtcbiAgICAvLyBIYW5kbGUgb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFVzZWQgbGF0ZXIgdG8gcmVmZXIgdG8gaXRcInMgcGFyZW50XG4gICAgb3B0aW9ucy5wYXJlbnQgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgRm9udCBBd2Vzb21lIG5lZWRzIHRvIGJlIGF1dG8gZG93bmxvYWRlZFxuICAgIHZhciBhdXRvRG93bmxvYWRGQSA9IHRydWU7XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvRG93bmxvYWRGb250QXdlc29tZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYXV0b0Rvd25sb2FkRkEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvRG93bmxvYWRGb250QXdlc29tZSAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgc3R5bGVTaGVldHMgPSBkb2N1bWVudC5zdHlsZVNoZWV0cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVNoZWV0c1tpXS5ocmVmKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGVTaGVldHNbaV0uaHJlZi5pbmRleE9mKCcvL21heGNkbi5ib290c3RyYXBjZG4uY29tL2ZvbnQtYXdlc29tZS8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgYXV0b0Rvd25sb2FkRkEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvRG93bmxvYWRGQSkge1xuICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICAgIGxpbmsuaHJlZiA9ICdodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2ZvbnQtYXdlc29tZS9sYXRlc3QvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzJztcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9XG5cblxuICAgIC8vIEZpbmQgdGhlIHRleHRhcmVhIHRvIHVzZVxuICAgIGlmIChvcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgZWxlbWVudCBvcHRpb24gd2FzIHNwZWNpZmllZCwgYnV0IG5vIGVsZW1lbnQgd2FzIGZvdW5kXG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBFcnJvci4gTm8gZWxlbWVudCB3YXMgZm91bmQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIEhhbmRsZSB0b29sYmFyXG4gICAgaWYgKG9wdGlvbnMudG9vbGJhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgICAgb3B0aW9ucy50b29sYmFyID0gW107XG5cblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGJ1aWx0IGluIGJ1dHRvbnMsIHRvIGdldCB0aGUgcHJlZmVycmVkIG9yZGVyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0b29sYmFyQnVpbHRJbkJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG9vbGJhckJ1aWx0SW5CdXR0b25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdzZXBhcmF0b3ItJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50b29sYmFyLnB1c2goJ3wnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG9vbGJhckJ1aWx0SW5CdXR0b25zW2tleV0uZGVmYXVsdCA9PT0gdHJ1ZSB8fCAob3B0aW9ucy5zaG93SWNvbnMgJiYgb3B0aW9ucy5zaG93SWNvbnMuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIG9wdGlvbnMuc2hvd0ljb25zLmluZGV4T2Yoa2V5KSAhPSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50b29sYmFyLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFZGl0b3IgcHJldmlldyBzdHlsaW5nIGNsYXNzLlxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdwcmV2aWV3Q2xhc3MnKSkge1xuICAgICAgICBvcHRpb25zLnByZXZpZXdDbGFzcyA9ICdlZGl0b3ItcHJldmlldyc7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHN0YXR1cyBiYXJcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc3RhdHVzJykpIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSBbJ2F1dG9zYXZlJywgJ2xpbmVzJywgJ3dvcmRzJywgJ2N1cnNvciddO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnVwbG9hZEltYWdlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXR1cy51bnNoaWZ0KCd1cGxvYWQtaW1hZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gQWRkIGRlZmF1bHQgcHJldmlldyByZW5kZXJpbmcgZnVuY3Rpb25cbiAgICBpZiAoIW9wdGlvbnMucHJldmlld1JlbmRlcikge1xuICAgICAgICBvcHRpb25zLnByZXZpZXdSZW5kZXIgPSBmdW5jdGlvbiAocGxhaW5UZXh0KSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBcInRoaXNcIiByZWZlcnMgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubWFya2Rvd24ocGxhaW5UZXh0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIFNldCBkZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgY29uZmlnXG4gICAgb3B0aW9ucy5wYXJzaW5nQ29uZmlnID0gZXh0ZW5kKHtcbiAgICAgICAgaGlnaGxpZ2h0Rm9ybWF0dGluZzogdHJ1ZSwgLy8gbmVlZGVkIGZvciB0b2dnbGVDb2RlQmxvY2sgdG8gZGV0ZWN0IHR5cGVzIG9mIGNvZGVcbiAgICB9LCBvcHRpb25zLnBhcnNpbmdDb25maWcgfHwge30pO1xuXG5cbiAgICAvLyBNZXJnaW5nIHRoZSBpbnNlcnRUZXh0cywgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgIG9wdGlvbnMuaW5zZXJ0VGV4dHMgPSBleHRlbmQoe30sIGluc2VydFRleHRzLCBvcHRpb25zLmluc2VydFRleHRzIHx8IHt9KTtcblxuXG4gICAgLy8gTWVyZ2luZyB0aGUgcHJvbXB0VGV4dHMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLnByb21wdFRleHRzID0gZXh0ZW5kKHt9LCBwcm9tcHRUZXh0cywgb3B0aW9ucy5wcm9tcHRUZXh0cyB8fCB7fSk7XG5cblxuICAgIC8vIE1lcmdpbmcgdGhlIGJsb2NrU3R5bGVzLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgb3B0aW9ucy5ibG9ja1N0eWxlcyA9IGV4dGVuZCh7fSwgYmxvY2tTdHlsZXMsIG9wdGlvbnMuYmxvY2tTdHlsZXMgfHwge30pO1xuXG5cbiAgICBpZiAob3B0aW9ucy5hdXRvc2F2ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTWVyZ2luZyB0aGUgQXV0b3NhdmUgdGltZUZvcm1hdCwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgICAgICBvcHRpb25zLmF1dG9zYXZlLnRpbWVGb3JtYXQgPSBleHRlbmQoe30sIHRpbWVGb3JtYXQsIG9wdGlvbnMuYXV0b3NhdmUudGltZUZvcm1hdCB8fCB7fSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pY29uQ2xhc3NNYXAgPSBleHRlbmQoe30sIGljb25DbGFzc01hcCwgb3B0aW9ucy5pY29uQ2xhc3NNYXAgfHwge30pO1xuXG4gICAgLy8gTWVyZ2luZyB0aGUgc2hvcnRjdXRzLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgb3B0aW9ucy5zaG9ydGN1dHMgPSBleHRlbmQoe30sIHNob3J0Y3V0cywgb3B0aW9ucy5zaG9ydGN1dHMgfHwge30pO1xuXG4gICAgb3B0aW9ucy5tYXhIZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodCB8fCB1bmRlZmluZWQ7XG5cbiAgICBvcHRpb25zLmRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8ICdsdHInO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTWluIGFuZCBtYXggaGVpZ2h0IGFyZSBlcXVhbCBpZiBtYXhIZWlnaHQgaXMgc2V0XG4gICAgICAgIG9wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5taW5IZWlnaHQgPSBvcHRpb25zLm1pbkhlaWdodCB8fCAnMzAwcHgnO1xuICAgIH1cblxuICAgIG9wdGlvbnMuZXJyb3JDYWxsYmFjayA9IG9wdGlvbnMuZXJyb3JDYWxsYmFjayB8fCBmdW5jdGlvbiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGFsZXJ0KGVycm9yTWVzc2FnZSk7XG4gICAgfTtcblxuICAgIC8vIEltcG9ydC1pbWFnZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICBvcHRpb25zLnVwbG9hZEltYWdlID0gb3B0aW9ucy51cGxvYWRJbWFnZSB8fCBmYWxzZTtcbiAgICBvcHRpb25zLmltYWdlTWF4U2l6ZSA9IG9wdGlvbnMuaW1hZ2VNYXhTaXplIHx8IDIwOTcxNTI7IC8vIDEwMjQgKiAxMDI0ICogMlxuICAgIG9wdGlvbnMuaW1hZ2VBY2NlcHQgPSBvcHRpb25zLmltYWdlQWNjZXB0IHx8ICdpbWFnZS9wbmcsIGltYWdlL2pwZWcsIGltYWdlL2dpZiwgaW1hZ2UvYXZpZic7XG4gICAgb3B0aW9ucy5pbWFnZVRleHRzID0gZXh0ZW5kKHt9LCBpbWFnZVRleHRzLCBvcHRpb25zLmltYWdlVGV4dHMgfHwge30pO1xuICAgIG9wdGlvbnMuZXJyb3JNZXNzYWdlcyA9IGV4dGVuZCh7fSwgZXJyb3JNZXNzYWdlcywgb3B0aW9ucy5lcnJvck1lc3NhZ2VzIHx8IHt9KTtcbiAgICBvcHRpb25zLmltYWdlUGF0aEFic29sdXRlID0gb3B0aW9ucy5pbWFnZVBhdGhBYnNvbHV0ZSB8fCBmYWxzZTtcbiAgICBvcHRpb25zLmltYWdlQ1NSRk5hbWUgPSBvcHRpb25zLmltYWdlQ1NSRk5hbWUgfHwgJ2NzcmZtaWRkbGV3YXJldG9rZW4nO1xuICAgIG9wdGlvbnMuaW1hZ2VDU1JGSGVhZGVyID0gb3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIgfHwgZmFsc2U7XG5cblxuICAgIC8vIENoYW5nZSB1bmlxdWVfaWQgdG8gdW5pcXVlSWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKG9wdGlvbnMuYXV0b3NhdmUgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYXV0b3NhdmUudW5pcXVlX2lkICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZV9pZCAhPSAnJylcbiAgICAgICAgb3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9IG9wdGlvbnMuYXV0b3NhdmUudW5pcXVlX2lkO1xuXG4gICAgLy8gSWYgb3ZlcmxheSBtb2RlIGlzIHNwZWNpZmllZCBhbmQgY29tYmluZSBpcyBub3QgcHJvdmlkZWQsIGRlZmF1bHQgaXQgdG8gdHJ1ZVxuICAgIGlmIChvcHRpb25zLm92ZXJsYXlNb2RlICYmIG9wdGlvbnMub3ZlcmxheU1vZGUuY29tYmluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMub3ZlcmxheU1vZGUuY29tYmluZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoaXMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblxuICAgIC8vIEF1dG8gcmVuZGVyXG4gICAgdGhpcy5yZW5kZXIoKTtcblxuXG4gICAgLy8gVGhlIGNvZGVtaXJyb3IgY29tcG9uZW50IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHJlbmRlcmluZ1xuICAgIC8vIHNvLCB0aGUgc2V0dGVyIGZvciB0aGUgaW5pdGlhbFZhbHVlIGNhbiBvbmx5IHJ1biBhZnRlclxuICAgIC8vIHRoZSBlbGVtZW50IGhhcyBiZWVuIHJlbmRlcmVkXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbFZhbHVlICYmICghdGhpcy5vcHRpb25zLmF1dG9zYXZlIHx8IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5mb3VuZFNhdmVkVmFsdWUgIT09IHRydWUpKSB7XG4gICAgICAgIHRoaXMudmFsdWUob3B0aW9ucy5pbml0aWFsVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVwbG9hZEltYWdlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYk9uRHJhZ0VudGVyKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcmFnbGVhdmUnLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcmFnb3ZlcicsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYk9uRHJhZ0VudGVyKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcm9wJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbihvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24sIGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbigncGFzdGUnLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXNVc2luZ0N1c3RvbUZ1bmN0aW9uKG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZXZlbnQuY2xpcGJvYXJkRGF0YS5maWxlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzKGV2ZW50LmNsaXBib2FyZERhdGEuZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVXBsb2FkIGFzeW5jaHJvbm91c2x5IGEgbGlzdCBvZiBpbWFnZXMgdG8gYSBzZXJ2ZXIuXG4gKlxuICogQ2FuIGJlIHRyaWdnZXJlZCBieTpcbiAqIC0gZHJhZyZkcm9wO1xuICogLSBjb3B5LXBhc3RlO1xuICogLSB0aGUgYnJvd3NlLWZpbGUgd2luZG93IChvcGVuZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlICp1cGxvYWQtaW1hZ2UqIGljb24pLlxuICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZXMgVGhlIGZpbGVzIHRvIHVwbG9hZCB0aGUgdGhlIHNlcnZlci5cbiAqIEBwYXJhbSBbb25TdWNjZXNzXSB7ZnVuY3Rpb259IHNlZSBFYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZVxuICogQHBhcmFtIFtvbkVycm9yXSB7ZnVuY3Rpb259IHNlZSBFYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZVxuICovXG5FYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZXMgPSBmdW5jdGlvbiAoZmlsZXMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgICAgIHRoaXMudXBsb2FkSW1hZ2UoZmlsZXNbaV0sIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCB0aGlzLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYk9uRHJvcC5yZXBsYWNlKCcjaW1hZ2VzX25hbWVzIycsIG5hbWVzLmpvaW4oJywgJykpKTtcbn07XG5cbi8qKlxuICogVXBsb2FkIGFzeW5jaHJvbm91c2x5IGEgbGlzdCBvZiBpbWFnZXMgdG8gYSBzZXJ2ZXIuXG4gKlxuICogQ2FuIGJlIHRyaWdnZXJlZCBieTpcbiAqIC0gZHJhZyZkcm9wO1xuICogLSBjb3B5LXBhc3RlO1xuICogLSB0aGUgYnJvd3NlLWZpbGUgd2luZG93IChvcGVuZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlICp1cGxvYWQtaW1hZ2UqIGljb24pLlxuICogQHBhcmFtIGltYWdlVXBsb2FkRnVuY3Rpb24ge0Z1bmN0aW9ufSBUaGUgY3VzdG9tIGZ1bmN0aW9uIHRvIHVwbG9hZCB0aGUgaW1hZ2UgcGFzc2VkIGluIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0ZpbGVMaXN0fSBmaWxlcyBUaGUgZmlsZXMgdG8gdXBsb2FkIHRoZSB0aGUgc2VydmVyLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZXNVc2luZ0N1c3RvbUZ1bmN0aW9uID0gZnVuY3Rpb24gKGltYWdlVXBsb2FkRnVuY3Rpb24sIGZpbGVzKSB7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZXMucHVzaChmaWxlc1tpXS5uYW1lKTtcbiAgICAgICAgdGhpcy51cGxvYWRJbWFnZVVzaW5nQ3VzdG9tRnVuY3Rpb24oaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZmlsZXNbaV0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgdGhpcy5vcHRpb25zLmltYWdlVGV4dHMuc2JPbkRyb3AucmVwbGFjZSgnI2ltYWdlc19uYW1lcyMnLCBuYW1lcy5qb2luKCcsICcpKSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBpdGVtIGluIHRoZSBzdGF0dXMgYmFyLlxuICogQHBhcmFtIGl0ZW1OYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHVwZGF0ZSAoaWUuICd1cGxvYWQtaW1hZ2UnLCAnYXV0b3NhdmUnLCBldGMuKS5cbiAqIEBwYXJhbSBjb250ZW50IHtzdHJpbmd9IHRoZSBuZXcgY29udGVudCBvZiB0aGUgaXRlbSB0byB3cml0ZSBpbiB0aGUgc3RhdHVzIGJhci5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBkYXRlU3RhdHVzQmFyID0gZnVuY3Rpb24gKGl0ZW1OYW1lLCBjb250ZW50KSB7XG4gICAgaWYgKCF0aGlzLmd1aS5zdGF0dXNiYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGluZ0NsYXNzZXMgPSB0aGlzLmd1aS5zdGF0dXNiYXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpdGVtTmFtZSk7XG4gICAgaWYgKG1hdGNoaW5nQ2xhc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5ndWkuc3RhdHVzYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaXRlbU5hbWUpWzBdLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9IGVsc2UgaWYgKG1hdGNoaW5nQ2xhc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IHN0YXR1cyBiYXIgaXRlbSAnICsgaXRlbU5hbWUgKyAnIHdhcyBub3QgZm91bmQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IFNldmVyYWwgc3RhdHVzIGJhciBpdGVtcyBuYW1lZCAnICsgaXRlbU5hbWUgKyAnIHdhcyBmb3VuZC4nKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlZmF1bHQgbWFya2Rvd24gcmVuZGVyLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS5tYXJrZG93biA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgaWYgKG1hcmtlZCkge1xuICAgICAgICAvLyBJbml0aWFsaXplXG4gICAgICAgIHZhciBtYXJrZWRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5tYXJrZWRPcHRpb25zKSB7XG4gICAgICAgICAgICBtYXJrZWRPcHRpb25zID0gdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5tYXJrZWRPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG9wdGlvbnNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuc2luZ2xlTGluZUJyZWFrcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMuYnJlYWtzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrZWRPcHRpb25zLmJyZWFrcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5jb2RlU3ludGF4SGlnaGxpZ2h0aW5nID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIC8qIEdldCBITEpTIGZyb20gY29uZmlnIG9yIHdpbmRvdyAqL1xuICAgICAgICAgICAgdmFyIGhsanMgPSB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLmhsanMgfHwgd2luZG93LmhsanM7XG5cbiAgICAgICAgICAgIC8qIENoZWNrIGlmIEhMSlMgbG9hZGVkICovXG4gICAgICAgICAgICBpZiAoaGxqcykge1xuICAgICAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSAmJiBobGpzLmdldExhbmd1YWdlKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmd1YWdlLCBjb2RlKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodEF1dG8oY29kZSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG9wdGlvbnNcbiAgICAgICAgbWFya2VkLnNldE9wdGlvbnMobWFya2VkT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgbWFya2Rvd24gdG8gSFRNTFxuICAgICAgICB2YXIgaHRtbFRleHQgPSBtYXJrZWQucGFyc2UodGV4dCk7XG5cbiAgICAgICAgLy8gU2FuaXRpemUgSFRNTFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5zYW5pdGl6ZXJGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaHRtbFRleHQgPSB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLnNhbml0aXplckZ1bmN0aW9uLmNhbGwodGhpcywgaHRtbFRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWRpdCB0aGUgSFRNTCBhbmNob3JzIHRvIGFkZCAndGFyZ2V0PVwiX2JsYW5rXCInIGJ5IGRlZmF1bHQuXG4gICAgICAgIGh0bWxUZXh0ID0gYWRkQW5jaG9yVGFyZ2V0QmxhbmsoaHRtbFRleHQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0LXN0eWxlIHdoZW4gcmVuZGVyaW5nIGNoZWNrYm94ZXNcbiAgICAgICAgaHRtbFRleHQgPSByZW1vdmVMaXN0U3R5bGVXaGVuQ2hlY2tib3goaHRtbFRleHQpO1xuXG4gICAgICAgIHJldHVybiBodG1sVGV4dDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbmRlciBlZGl0b3IgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSB0aGlzLmVsZW1lbnQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RleHRhcmVhJylbMF07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkICYmIHRoaXMuX3JlbmRlcmVkID09PSBlbCkge1xuICAgICAgICAvLyBBbHJlYWR5IHJlbmRlcmVkLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50ID0gZWw7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleU1hcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnNob3J0Y3V0cykge1xuICAgICAgICAvLyBudWxsIHN0YW5kcyBmb3IgXCJkbyBub3QgYmluZCB0aGlzIGNvbW1hbmRcIlxuICAgICAgICBpZiAob3B0aW9ucy5zaG9ydGN1dHNba2V5XSAhPT0gbnVsbCAmJiBiaW5kaW5nc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGtleU1hcHNbZml4U2hvcnRjdXQob3B0aW9ucy5zaG9ydGN1dHNba2V5XSldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gYmluZGluZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oYWN0aW9uLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtleU1hcHNbJ0VudGVyJ10gPSAnbmV3bGluZUFuZEluZGVudENvbnRpbnVlTWFya2Rvd25MaXN0JztcbiAgICBrZXlNYXBzWydUYWInXSA9ICd0YWJBbmRJbmRlbnRNYXJrZG93bkxpc3QnO1xuICAgIGtleU1hcHNbJ1NoaWZ0LVRhYiddID0gJ3NoaWZ0VGFiQW5kVW5pbmRlbnRNYXJrZG93bkxpc3QnO1xuICAgIGtleU1hcHNbJ0VzYyddID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgIGlmIChjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkgdG9nZ2xlRnVsbFNjcmVlbihzZWxmKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kb2N1bWVudE9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb2RlbWlycm9yLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB0b2dnbGVGdWxsU2NyZWVuKHNlbGYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5kb2N1bWVudE9uS2V5RG93biwgZmFsc2UpO1xuXG4gICAgdmFyIG1vZGUsIGJhY2tkcm9wO1xuXG4gICAgLy8gQ29kZU1pcnJvciBvdmVybGF5IG1vZGVcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5TW9kZSkge1xuICAgICAgICBDb2RlTWlycm9yLmRlZmluZU1vZGUoJ292ZXJsYXktbW9kZScsIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLm92ZXJsYXlNb2RlKENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIG9wdGlvbnMuc3BlbGxDaGVja2VyICE9PSBmYWxzZSA/ICdzcGVsbC1jaGVja2VyJyA6ICdnZm0nKSwgb3B0aW9ucy5vdmVybGF5TW9kZS5tb2RlLCBvcHRpb25zLm92ZXJsYXlNb2RlLmNvbWJpbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlID0gJ292ZXJsYXktbW9kZSc7XG4gICAgICAgIGJhY2tkcm9wID0gb3B0aW9ucy5wYXJzaW5nQ29uZmlnO1xuICAgICAgICBiYWNrZHJvcC5naXRIdWJTcGljZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGUgPSBvcHRpb25zLnBhcnNpbmdDb25maWc7XG4gICAgICAgIG1vZGUubmFtZSA9ICdnZm0nO1xuICAgICAgICBtb2RlLmdpdEh1YlNwaWNlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNwZWxsQ2hlY2tlciAhPT0gZmFsc2UpIHtcbiAgICAgICAgbW9kZSA9ICdzcGVsbC1jaGVja2VyJztcbiAgICAgICAgYmFja2Ryb3AgPSBvcHRpb25zLnBhcnNpbmdDb25maWc7XG4gICAgICAgIGJhY2tkcm9wLm5hbWUgPSAnZ2ZtJztcbiAgICAgICAgYmFja2Ryb3AuZ2l0SHViU3BpY2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3BlbGxDaGVja2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNwZWxsQ2hlY2tlcih7XG4gICAgICAgICAgICAgICAgY29kZU1pcnJvckluc3RhbmNlOiBDb2RlTWlycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDb2RlTWlycm9yU3BlbGxDaGVja2VyKHtcbiAgICAgICAgICAgICAgICBjb2RlTWlycm9ySW5zdGFuY2U6IENvZGVNaXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGROZXc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuY29kZW1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsLCB7XG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGJhY2tkcm9wOiBiYWNrZHJvcCxcbiAgICAgICAgdGhlbWU6IChvcHRpb25zLnRoZW1lICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRoZW1lIDogJ2Vhc3ltZGUnLFxuICAgICAgICB0YWJTaXplOiAob3B0aW9ucy50YWJTaXplICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRhYlNpemUgOiAyLFxuICAgICAgICBpbmRlbnRVbml0OiAob3B0aW9ucy50YWJTaXplICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnRhYlNpemUgOiAyLFxuICAgICAgICBpbmRlbnRXaXRoVGFiczogKG9wdGlvbnMuaW5kZW50V2l0aFRhYnMgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgbGluZU51bWJlcnM6IChvcHRpb25zLmxpbmVOdW1iZXJzID09PSB0cnVlKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgYXV0b2ZvY3VzOiAob3B0aW9ucy5hdXRvZm9jdXMgPT09IHRydWUpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICBleHRyYUtleXM6IGtleU1hcHMsXG4gICAgICAgIGRpcmVjdGlvbjogb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgIGxpbmVXcmFwcGluZzogKG9wdGlvbnMubGluZVdyYXBwaW5nID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgIGFsbG93RHJvcEZpbGVUeXBlczogWyd0ZXh0L3BsYWluJ10sXG4gICAgICAgIHBsYWNlaG9sZGVyOiBvcHRpb25zLnBsYWNlaG9sZGVyIHx8IGVsLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCAnJyxcbiAgICAgICAgc3R5bGVTZWxlY3RlZFRleHQ6IChvcHRpb25zLnN0eWxlU2VsZWN0ZWRUZXh0ICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnN0eWxlU2VsZWN0ZWRUZXh0IDogIWlzTW9iaWxlKCksXG4gICAgICAgIHNjcm9sbGJhclN0eWxlOiAob3B0aW9ucy5zY3JvbGxiYXJTdHlsZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5zY3JvbGxiYXJTdHlsZSA6ICduYXRpdmUnLFxuICAgICAgICBjb25maWd1cmVNb3VzZTogY29uZmlndXJlTW91c2UsXG4gICAgICAgIGlucHV0U3R5bGU6IChvcHRpb25zLmlucHV0U3R5bGUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuaW5wdXRTdHlsZSA6IGlzTW9iaWxlKCkgPyAnY29udGVudGVkaXRhYmxlJyA6ICd0ZXh0YXJlYScsXG4gICAgICAgIHNwZWxsY2hlY2s6IChvcHRpb25zLm5hdGl2ZVNwZWxsY2hlY2sgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMubmF0aXZlU3BlbGxjaGVjayA6IHRydWUsXG4gICAgICAgIGF1dG9SZWZyZXNoOiAob3B0aW9ucy5hdXRvUmVmcmVzaCAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5hdXRvUmVmcmVzaCA6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb2RlbWlycm9yLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLm1pbkhlaWdodCA9IG9wdGlvbnMubWluSGVpZ2h0O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcmNlU3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgICAgIGNtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbS5zYXZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZ3VpID0ge307XG5cbiAgICAvLyBXcmFwIENvZGVtaXJyb3Igd2l0aCBjb250YWluZXIgYmVmb3JlIGNyZWF0ZSB0b29sYmFyLCBldGMsXG4gICAgLy8gdG8gdXNlIHdpdGggc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gb3B0aW9uLlxuICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdFYXN5TURFQ29udGFpbmVyJyk7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYXBwbGljYXRpb24nKTtcbiAgICB2YXIgY21XcmFwcGVyID0gdGhpcy5jb2RlbWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgY21XcmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVhc3lNREVDb250YWluZXIsIGNtV3JhcHBlcik7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5hcHBlbmRDaGlsZChjbVdyYXBwZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMudG9vbGJhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ndWkudG9vbGJhciA9IHRoaXMuY3JlYXRlVG9vbGJhcigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGF0dXMgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZ3VpLnN0YXR1c2JhciA9IHRoaXMuY3JlYXRlU3RhdHVzYmFyKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF1dG9zYXZlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSgpOyAvLyB1c2UgdG8gbG9hZCBsb2NhbHN0b3JhZ2UgY29udGVudFxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9hdXRvc2F2ZV90aW1lb3V0KTtcbiAgICAgICAgICAgIHNlbGYuX2F1dG9zYXZlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmF1dG9zYXZlKCk7XG4gICAgICAgICAgICB9LCBzZWxmLm9wdGlvbnMuYXV0b3NhdmUuc3VibWl0X2RlbGF5IHx8IHNlbGYub3B0aW9ucy5hdXRvc2F2ZS5kZWxheSB8fCAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0hlaWdodChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgdmFyIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuQ29kZU1pcnJvci1zaXplcicpKS53aWR0aC5yZXBsYWNlKCdweCcsICcnKTtcbiAgICAgICAgaWYgKG5hdHVyYWxXaWR0aCA8IHZpZXdwb3J0V2lkdGgpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG5hdHVyYWxIZWlnaHQgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gKG5hdHVyYWxIZWlnaHQgLyBuYXR1cmFsV2lkdGggKiAxMDApICsgJyUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIF92bSA9IHRoaXM7XG5cblxuICAgIGZ1bmN0aW9uIGFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzKHBhcmVudEVsLCBpbWcpIHtcbiAgICAgICAgcGFyZW50RWwuc2V0QXR0cmlidXRlKCdkYXRhLWltZy1zcmMnLCBpbWcudXJsKTtcbiAgICAgICAgcGFyZW50RWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICctLWJnLWltYWdlOnVybCgnICsgaW1nLnVybCArICcpOy0td2lkdGg6JyArIGltZy5uYXR1cmFsV2lkdGggKyAncHg7LS1oZWlnaHQ6JyArIGNhbGNIZWlnaHQoaW1nLm5hdHVyYWxXaWR0aCwgaW1nLm5hdHVyYWxIZWlnaHQpKTtcbiAgICAgICAgX3ZtLmNvZGVtaXJyb3Iuc2V0U2l6ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUltYWdlcygpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnByZXZpZXdJbWFnZXNJbkVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuY20taW1hZ2UtbWFya2VyJykuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRFbC5pbm5lclRleHQubWF0Y2goL14hXFxbLio/XFxdXFwoLipcXCkvZykpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbWcgcGFzdGVkIG9uIHRoZSBzYW1lIGxpbmUgd2l0aCBvdGhlciB0ZXh0LCBkb24ndCBwcmV2aWV3LCBwcmV2aWV3IG9ubHkgaW1hZ2VzIG9uIHNlcGFyYXRlIGxpbmVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudEVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1pbWctc3JjJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3JjQXR0ciA9IHBhcmVudEVsLmlubmVyVGV4dC5tYXRjaCgnXFxcXCgoLiopXFxcXCknKTsgLy8gbWlnaHQgcmVxdWlyZSBiZXR0ZXIgcGFyc2luZyBhY2NvcmRpbmcgdG8gbWFya2Rvd24gc3BlY1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LkVNREVpbWFnZXNDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuRU1ERWltYWdlc0NhY2hlID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNyY0F0dHIgJiYgc3JjQXR0ci5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5U3JjID0gc3JjQXR0clsxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbWFnZXNQcmV2aWV3SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NyYyA9IG9wdGlvbnMuaW1hZ2VzUHJldmlld0hhbmRsZXIoc3JjQXR0clsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlbnNpdmUgY2hlY2sgbWFraW5nIHN1cmUgdGhlIGhhbmRsZXIgcHJvdmlkZWQgYnkgdGhlIHVzZXIgcmV0dXJucyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5U3JjID0gbmV3U3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGg6IGltZy5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGtleVNyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzKHBhcmVudEVsLCB3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBrZXlTcmM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25JbWFnZUJsb2NrQXR0cmlidXRlcyhwYXJlbnRFbCwgd2luZG93LkVNREVpbWFnZXNDYWNoZVtrZXlTcmNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlbWlycm9yLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZUltYWdlcygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ndWkuc2lkZUJ5U2lkZSA9IHRoaXMuY3JlYXRlU2lkZUJ5U2lkZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVkID0gdGhpcy5lbGVtZW50O1xuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09PSB0cnVlIHx8IGVsLmF1dG9mb2N1cykge1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3IuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBGaXhlcyBDb2RlTWlycm9yIGJ1ZyAoIzM0NClcbiAgICB2YXIgdGVtcF9jbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVtcF9jbS5yZWZyZXNoKCk7XG4gICAgfS5iaW5kKHRlbXBfY20pLCAwKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZG9jdW1lbnRPbktleURvd24pO1xufTtcblxuLy8gU2FmYXJpLCBpbiBQcml2YXRlIEJyb3dzaW5nIE1vZGUsIGxvb2tzIGxpa2UgaXQgc3VwcG9ydHMgbG9jYWxTdG9yYWdlIGJ1dCBhbGwgY2FsbHMgdG8gc2V0SXRlbSB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3IuIFdlJ3JlIGdvaW5nIHRvIGRldGVjdCB0aGlzIGFuZCBzZXQgYSB2YXJpYWJsZSBhY2NvcmRpbmdseS5cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NtZGVfbG9jYWxTdG9yYWdlJywgMSk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc21kZV9sb2NhbFN0b3JhZ2UnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5FYXN5TURFLnByb3RvdHlwZS5hdXRvc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICB2YXIgZWFzeU1ERSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID09ICcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogWW91IG11c3Qgc2V0IGEgdW5pcXVlSWQgdG8gdXNlIHRoZSBhdXRvc2F2ZSBmZWF0dXJlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlLmJpbmRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGVhc3lNREUuZWxlbWVudC5mb3JtICE9IG51bGwgJiYgZWFzeU1ERS5lbGVtZW50LmZvcm0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZWFzeU1ERS5lbGVtZW50LmZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZWFzeU1ERS5hdXRvc2F2ZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGVhc3lNREUuYXV0b3NhdmVUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIGVhc3lNREUub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5iaW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5sb2FkZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkgPT0gJ3N0cmluZycgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGVtaXJyb3Iuc2V0VmFsdWUobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5mb3VuZFNhdmVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3NhdmUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IGVhc3lNREUudmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXV0b3NhdmVkJyk7XG4gICAgICAgIGlmIChlbCAhPSBudWxsICYmIGVsICE9IHVuZGVmaW5lZCAmJiBlbCAhPSAnJykge1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGRkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW3RoaXMub3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0LmxvY2FsZSwgJ2VuLVVTJ10sIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0LmZvcm1hdCkuZm9ybWF0KGQpO1xuICAgICAgICAgICAgdmFyIHNhdmUgPSB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudGV4dCA9PSB1bmRlZmluZWQgPyAnQXV0b3NhdmVkOiAnIDogdGhpcy5vcHRpb25zLmF1dG9zYXZlLnRleHQ7XG5cbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHNhdmUgKyBkZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgY2Fubm90IGF1dG9zYXZlJyk7XG4gICAgfVxufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY2xlYXJBdXRvc2F2ZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSAnJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IFlvdSBtdXN0IHNldCBhIHVuaXF1ZUlkIHRvIGNsZWFyIHRoZSBhdXRvc2F2ZSB2YWx1ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3NtZGVfJyArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IGxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCBjYW5ub3QgYXV0b3NhdmUnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE9wZW4gdGhlIGJyb3dzZS1maWxlIHdpbmRvdyB0byB1cGxvYWQgYW4gaW1hZ2UgdG8gYSBzZXJ2ZXIuXG4gKiBAcGFyYW0gW29uU3VjY2Vzc10ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqIEBwYXJhbSBbb25FcnJvcl0ge2Z1bmN0aW9ufSBzZWUgRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VcbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUub3BlbkJyb3dzZUZpbGVXaW5kb3cgPSBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbWFnZUlucHV0ID0gdGhpcy5ndWkudG9vbGJhci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbWFnZUlucHV0JylbMF07XG4gICAgaW1hZ2VJbnB1dC5jbGljaygpOyAvL2Rpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpOyAgLy8gcmVwbGFjZWQgd2l0aCBjbGljaygpIGZvciBJRTExIGNvbXBhdGliaWxpdHkuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24oc2VsZi5vcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24sIGV2ZW50LnRhcmdldC5maWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlcyhldmVudC50YXJnZXQuZmlsZXMsIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfVxuXG4gICAgaW1hZ2VJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhbiBpbWFnZSB0byB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBmaWxlIHtGaWxlfSBUaGUgaW1hZ2UgdG8gdXBsb2FkLCBhcyBhIEhUTUw1IEZpbGUgb2JqZWN0IChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSlcbiAqIEBwYXJhbSBbb25TdWNjZXNzXSB7ZnVuY3Rpb259IEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkLCB3aXRoIG9uZSBwYXJhbWV0ZXI6XG4gKiAtIHVybCAoc3RyaW5nKTogVGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgaW1hZ2UuXG4gKiBAcGFyYW0gW29uRXJyb3JdIHtmdW5jdGlvbn0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGltYWdlIHVwbG9hZCBmYWlscywgd2l0aCBvbmUgcGFyYW1ldGVyOlxuICogLSBlcnJvciAoc3RyaW5nKTogdGhlIGRldGFpbGVkIGVycm9yIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIgKGJhc2VkIG9uIG1lc3NhZ2VzIGZyb20gb3B0aW9ucy5lcnJvck1lc3NhZ2VzKS5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2UgPSBmdW5jdGlvbiAoZmlsZSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9uU3VjY2VzcyA9IG9uU3VjY2VzcyB8fCBmdW5jdGlvbiBvblN1Y2Nlc3MoaW1hZ2VVcmwpIHtcbiAgICAgICAgYWZ0ZXJJbWFnZVVwbG9hZGVkKHNlbGYsIGltYWdlVXJsKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25FcnJvclN1cChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgLy8gc2hvdyBlcnJvciBvbiBzdGF0dXMgYmFyIGFuZCByZXNldCBhZnRlciAxMDAwMG1zXG4gICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAvLyBydW4gY3VzdG9tIGVycm9yIGhhbmRsZXJcbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBydW4gZXJyb3IgaGFuZGxlciBmcm9tIG9wdGlvbnMsIHRoaXMgYWxlcnRzIHRoZSBtZXNzYWdlLlxuICAgICAgICBzZWxmLm9wdGlvbnMuZXJyb3JDYWxsYmFjayhlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNpemVVbml0cy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX25hbWUjJywgZmlsZS5uYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9zaXplIycsIGh1bWFuRmlsZVNpemUoZmlsZS5zaXplLCB1bml0cykpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX21heF9zaXplIycsIGh1bWFuRmlsZVNpemUoc2VsZi5vcHRpb25zLmltYWdlTWF4U2l6ZSwgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmltYWdlTWF4U2l6ZSkge1xuICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2UodGhpcy5vcHRpb25zLmVycm9yTWVzc2FnZXMuZmlsZVRvb0xhcmdlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ltYWdlJywgZmlsZSk7XG5cbiAgICAvLyBpbnNlcnQgQ1NSRiBib2R5IHRva2VuIGlmIHByb3ZpZGVkIGluIGNvbmZpZy5cbiAgICBpZiAoc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuICYmICFzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGSGVhZGVyKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGTmFtZSwgc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuKTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9ICcnICsgTWF0aC5yb3VuZCgoZXZlbnQubG9hZGVkICogMTAwKSAvIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYlByb2dyZXNzLnJlcGxhY2UoJyNmaWxlX25hbWUjJywgZmlsZS5uYW1lKS5yZXBsYWNlKCcjcHJvZ3Jlc3MjJywgcHJvZ3Jlc3MpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdGhpcy5vcHRpb25zLmltYWdlVXBsb2FkRW5kcG9pbnQpO1xuXG4gICAgLy8gaW5zZXJ0IENTUkYgaGVhZGVyIHRva2VuIGlmIHByb3ZpZGVkIGluIGNvbmZpZy5cbiAgICBpZiAoc2VsZi5vcHRpb25zLmltYWdlQ1NSRlRva2VuICYmIHNlbGYub3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKHNlbGYub3B0aW9ucy5pbWFnZUNTUkZOYW1lLCBzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGVG9rZW4pO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFYXN5TURFOiBUaGUgc2VydmVyIGRpZCBub3QgcmV0dXJuIGEgdmFsaWQganNvbi4nKTtcbiAgICAgICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZShzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlcy5pbXBvcnRFcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlICYmICFyZXNwb25zZS5lcnJvciAmJiByZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzcygoc2VsZi5vcHRpb25zLmltYWdlUGF0aEFic29sdXRlID8gJycgOiAod2luZG93LmxvY2F0aW9uLm9yaWdpbiArICcvJykpICsgcmVzcG9uc2UuZGF0YS5maWxlUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UuZXJyb3IgaW4gc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXMpIHsgIC8vIHByZWZvcm1hdHRlZCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzW3Jlc3BvbnNlLmVycm9yXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5lcnJvcikgeyAgLy8gc2VydmVyIHNpZGUgZ2VuZXJhdGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2UocmVzcG9uc2UuZXJyb3IpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7ICAvL3Vua25vd24gZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFYXN5TURFOiBSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHJlc3BvbnNlIGFmdGVyIHVwbG9hZGluZyB0aGUgaW1hZ2UuJ1xuICAgICAgICAgICAgICAgICAgICArIHRoaXMuc3RhdHVzICsgJyAoJyArIHRoaXMuc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmltcG9ydEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vhc3lNREU6IEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gdXBsb2FkIHRoZSBpbWFnZS4nXG4gICAgICAgICAgICArIGV2ZW50LnRhcmdldC5zdGF0dXMgKyAnICgnICsgZXZlbnQudGFyZ2V0LnN0YXR1c1RleHQgKyAnKScpO1xuICAgICAgICBvbkVycm9yU3VwKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmltcG9ydEVycm9yKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKGZvcm1EYXRhKTtcblxufTtcblxuLyoqXG4gKiBVcGxvYWQgYW4gaW1hZ2UgdG8gdGhlIHNlcnZlciB1c2luZyBhIGN1c3RvbSB1cGxvYWQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGltYWdlVXBsb2FkRnVuY3Rpb24ge0Z1bmN0aW9ufSBUaGUgY3VzdG9tIGZ1bmN0aW9uIHRvIHVwbG9hZCB0aGUgaW1hZ2UgcGFzc2VkIGluIG9wdGlvbnNcbiAqIEBwYXJhbSBmaWxlIHtGaWxlfSBUaGUgaW1hZ2UgdG8gdXBsb2FkLCBhcyBhIEhUTUw1IEZpbGUgb2JqZWN0IChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlVXNpbmdDdXN0b21GdW5jdGlvbiA9IGZ1bmN0aW9uIChpbWFnZVVwbG9hZEZ1bmN0aW9uLCBmaWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gb25TdWNjZXNzKGltYWdlVXJsKSB7XG4gICAgICAgIGFmdGVySW1hZ2VVcGxvYWRlZChzZWxmLCBpbWFnZVVybCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGZpbGxlZEVycm9yTWVzc2FnZSA9IGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgLy8gc2hvdyBlcnJvciBvbiBzdGF0dXMgYmFyIGFuZCByZXNldCBhZnRlciAxMDAwMG1zXG4gICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBmaWxsZWRFcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAvLyBydW4gZXJyb3IgaGFuZGxlciBmcm9tIG9wdGlvbnMsIHRoaXMgYWxlcnRzIHRoZSBtZXNzYWdlLlxuICAgICAgICBzZWxmLm9wdGlvbnMuZXJyb3JDYWxsYmFjayhmaWxsZWRFcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxFcnJvck1lc3NhZ2UoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNpemVVbml0cy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX25hbWUjJywgZmlsZS5uYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoJyNpbWFnZV9zaXplIycsIGh1bWFuRmlsZVNpemUoZmlsZS5zaXplLCB1bml0cykpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX21heF9zaXplIycsIGh1bWFuRmlsZVNpemUoc2VsZi5vcHRpb25zLmltYWdlTWF4U2l6ZSwgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBpbWFnZVVwbG9hZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtmaWxlLCBvblN1Y2Nlc3MsIG9uRXJyb3JdKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLnNldFByZXZpZXdNYXhIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICAvLyBDYWxjIHByZXZpZXcgbWF4IGhlaWdodFxuICAgIHZhciBwYWRkaW5nVG9wID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUod3JhcHBlcikucGFkZGluZ1RvcCk7XG4gICAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUod3JhcHBlcikuYm9yZGVyVG9wV2lkdGgpO1xuICAgIHZhciBvcHRpb25zTWF4SGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLm1heEhlaWdodCk7XG4gICAgdmFyIHdyYXBwZXJNYXhIZWlnaHQgPSBvcHRpb25zTWF4SGVpZ2h0ICsgcGFkZGluZ1RvcCAqIDIgKyBib3JkZXJUb3BXaWR0aCAqIDI7XG4gICAgdmFyIHByZXZpZXdNYXhIZWlnaHQgPSB3cmFwcGVyTWF4SGVpZ2h0LnRvU3RyaW5nKCkgKyAncHgnO1xuXG4gICAgcHJldmlldy5zdHlsZS5oZWlnaHQgPSBwcmV2aWV3TWF4SGVpZ2h0O1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY3JlYXRlU2lkZUJ5U2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5uZXh0U2libGluZztcblxuICAgIGlmICghcHJldmlldyB8fCAhcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LXNpZGUnKSkge1xuICAgICAgICBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHByZXZpZXcuY2xhc3NOYW1lID0gJ2VkaXRvci1wcmV2aWV3LXNpZGUnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzKSB7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXcuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMucHJldmlld0NsYXNzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwcmV2aWV3LCB3cmFwcGVyLm5leHRTaWJsaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5tYXhIZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2V0UHJldmlld01heEhlaWdodCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3luY1NpZGVCeVNpZGVQcmV2aWV3U2Nyb2xsID09PSBmYWxzZSkgcmV0dXJuIHByZXZpZXc7XG4gICAgLy8gU3luY3Mgc2Nyb2xsICBlZGl0b3IgLT4gcHJldmlld1xuICAgIHZhciBjU2Nyb2xsID0gZmFsc2U7XG4gICAgdmFyIHBTY3JvbGwgPSBmYWxzZTtcbiAgICBjbS5vbignc2Nyb2xsJywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKGNTY3JvbGwpIHtcbiAgICAgICAgICAgIGNTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHYuZ2V0U2Nyb2xsSW5mbygpLmhlaWdodCAtIHYuZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHJhdGlvID0gcGFyc2VGbG9hdCh2LmdldFNjcm9sbEluZm8oKS50b3ApIC8gaGVpZ2h0O1xuICAgICAgICB2YXIgbW92ZSA9IChwcmV2aWV3LnNjcm9sbEhlaWdodCAtIHByZXZpZXcuY2xpZW50SGVpZ2h0KSAqIHJhdGlvO1xuICAgICAgICBwcmV2aWV3LnNjcm9sbFRvcCA9IG1vdmU7XG4gICAgfSk7XG5cbiAgICAvLyBTeW5jcyBzY3JvbGwgIHByZXZpZXcgLT4gZWRpdG9yXG4gICAgcHJldmlldy5vbnNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBTY3JvbGwpIHtcbiAgICAgICAgICAgIHBTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHByZXZpZXcuc2Nyb2xsSGVpZ2h0IC0gcHJldmlldy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciByYXRpbyA9IHBhcnNlRmxvYXQocHJldmlldy5zY3JvbGxUb3ApIC8gaGVpZ2h0O1xuICAgICAgICB2YXIgbW92ZSA9IChjbS5nZXRTY3JvbGxJbmZvKCkuaGVpZ2h0IC0gY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodCkgKiByYXRpbztcbiAgICAgICAgY20uc2Nyb2xsVG8oMCwgbW92ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcHJldmlldztcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNyZWF0ZVRvb2xiYXIgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpdGVtcyA9IGl0ZW1zIHx8IHRoaXMub3B0aW9ucy50b29sYmFyO1xuXG4gICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRvb2xiYXJCdWlsdEluQnV0dG9uc1tpdGVtc1tpXV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtc1tpXSA9IHRvb2xiYXJCdWlsdEluQnV0dG9uc1tpdGVtc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICdlZGl0b3ItdG9vbGJhcic7XG4gICAgYmFyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sYmFyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgdG9vbGJhckRhdGEgPSB7fTtcbiAgICBzZWxmLnRvb2xiYXIgPSBpdGVtcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbXNbaV0ubmFtZSA9PSAnZ3VpZGUnICYmIHNlbGYub3B0aW9ucy50b29sYmFyR3VpZGVJY29uID09PSBmYWxzZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaGlkZUljb25zICYmIHNlbGYub3B0aW9ucy5oaWRlSWNvbnMuaW5kZXhPZihpdGVtc1tpXS5uYW1lKSAhPSAtMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEZ1bGxzY3JlZW4gZG9lcyBub3Qgd29yayB3ZWxsIG9uIG1vYmlsZSBkZXZpY2VzIChldmVuIHRhYmxldHMpXG4gICAgICAgIC8vIEluIHRoZSBmdXR1cmUsIGhvcGVmdWxseSB0aGlzIGNhbiBiZSByZXNvbHZlZFxuICAgICAgICBpZiAoKGl0ZW1zW2ldLm5hbWUgPT0gJ2Z1bGxzY3JlZW4nIHx8IGl0ZW1zW2ldLm5hbWUgPT0gJ3NpZGUtYnktc2lkZScpICYmIGlzTW9iaWxlKCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuXG4gICAgICAgIC8vIERvbid0IGluY2x1ZGUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBpZiAoaXRlbXNbaV0gPT09ICd8Jykge1xuICAgICAgICAgICAgdmFyIG5vblNlcGFyYXRvckljb25zRm9sbG93ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHggPSAoaSArIDEpOyB4IDwgaXRlbXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNbeF0gIT09ICd8JyAmJiAoIXNlbGYub3B0aW9ucy5oaWRlSWNvbnMgfHwgc2VsZi5vcHRpb25zLmhpZGVJY29ucy5pbmRleE9mKGl0ZW1zW3hdLm5hbWUpID09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBub25TZXBhcmF0b3JJY29uc0ZvbGxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5vblNlcGFyYXRvckljb25zRm9sbG93KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGljb24gYW5kIGFwcGVuZCB0byB0aGUgdG9vbGJhclxuICAgICAgICAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGNyZWF0ZVNlcCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVUb29sYmFyRHJvcGRvd24oaXRlbSwgc2VsZi5vcHRpb25zLnRvb2xiYXJUaXBzLCBzZWxmLm9wdGlvbnMuc2hvcnRjdXRzLCBzZWxmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVUb29sYmFyQnV0dG9uKGl0ZW0sIHRydWUsIHNlbGYub3B0aW9ucy50b29sYmFyVGlwcywgc2VsZi5vcHRpb25zLnNob3J0Y3V0cywgJ2J1dHRvbicsIHNlbGYpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRvb2xiYXJEYXRhW2l0ZW0ubmFtZSB8fCBpdGVtXSA9IGVsO1xuICAgICAgICAgICAgYmFyLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbnB1dCBlbGVtZW50IChpZS4gPGlucHV0IHR5cGU9J2ZpbGUnPiksIHVzZWQgYW1vbmdcbiAgICAgICAgICAgIC8vIHdpdGggdGhlICdpbXBvcnQtaW1hZ2UnIGljb24gdG8gb3BlbiB0aGUgYnJvd3NlLWZpbGUgd2luZG93LlxuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PT0gJ3VwbG9hZC1pbWFnZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5jbGFzc05hbWUgPSAnaW1hZ2VJbnB1dCc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC50eXBlID0gJ2ZpbGUnO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQubmFtZSA9ICdpbWFnZSc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5hY2NlcHQgPSBzZWxmLm9wdGlvbnMuaW1hZ2VBY2NlcHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGltYWdlSW5wdXQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgYmFyLmFwcGVuZENoaWxkKGltYWdlSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShpdGVtc1tpXSk7XG4gICAgfVxuXG4gICAgc2VsZi50b29sYmFyX2RpdiA9IGJhcjtcbiAgICBzZWxmLnRvb2xiYXJFbGVtZW50cyA9IHRvb2xiYXJEYXRhO1xuXG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIGNtLm9uKCdjdXJzb3JBY3Rpdml0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvb2xiYXJEYXRhKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRvb2xiYXJEYXRhW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSAhPSAnZnVsbHNjcmVlbicgJiYga2V5ICE9ICdzaWRlLWJ5LXNpZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjbVdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIGNtV3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiYXIsIGNtV3JhcHBlcik7XG4gICAgcmV0dXJuIGJhcjtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmNyZWF0ZVN0YXR1c2JhciA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgc3RhdHVzID0gc3RhdHVzIHx8IHRoaXMub3B0aW9ucy5zdGF0dXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0dXMgdmFyaWFibGUgaXMgdmFsaWRcbiAgICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIGJ1aWx0LWluIGl0ZW1zXG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIGksIG9uVXBkYXRlLCBvbkFjdGl2aXR5LCBkZWZhdWx0VmFsdWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFJlc2V0IHNvbWUgdmFsdWVzXG4gICAgICAgIG9uVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICBvbkFjdGl2aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG5cblxuICAgICAgICAvLyBIYW5kbGUgaWYgY3VzdG9tIG9yIG5vdFxuICAgICAgICBpZiAodHlwZW9mIHN0YXR1c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogc3RhdHVzW2ldLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHN0YXR1c1tpXS5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IHN0YXR1c1tpXS5vblVwZGF0ZSxcbiAgICAgICAgICAgICAgICBvbkFjdGl2aXR5OiBzdGF0dXNbaV0ub25BY3Rpdml0eSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBzdGF0dXNbaV07XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnd29yZHMnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHdvcmRDb3VudChjbS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHdvcmRDb3VudChjbS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnbGluZXMnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGNtLmxpbmVDb3VudCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25VcGRhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2N1cnNvcicpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJzE6MSc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvbkFjdGl2aXR5ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0xpbmUgPSBwb3MubGluZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NDb2x1bW4gPSBwb3MuY2ggKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBwb3NMaW5lICsgJzonICsgcG9zQ29sdW1uO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdhdXRvc2F2ZScpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b3NhdmUgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYXV0b3NhdmUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdpZCcsICdhdXRvc2F2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1cGxvYWQtaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IG9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgICAgICAgICBvbkFjdGl2aXR5OiBvbkFjdGl2aXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGZvciB0aGUgc3RhdHVzIGJhclxuICAgIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYXIuY2xhc3NOYW1lID0gJ2VkaXRvci1zdGF0dXNiYXInO1xuXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgc3BhbiBmb3IgZWFjaCBpdGVtXG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFN0b3JlIGluIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXG5cbiAgICAgICAgLy8gQ3JlYXRlIHNwYW4gZWxlbWVudFxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGl0ZW0uY2xhc3NOYW1lO1xuXG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBkZWZhdWx0VmFsdWUgaXMgYSBmdW5jdGlvblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVtLmRlZmF1bHRWYWx1ZShlbCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgb25VcGRhdGUgaXMgYSBmdW5jdGlvblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ub25VcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNsb3N1cmUgYXJvdW5kIHRoZSBzcGFuIG9mIHRoZSBjdXJyZW50IGFjdGlvbiwgdGhlbiBleGVjdXRlIHRoZSBvblVwZGF0ZSBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ3VwZGF0ZScsIChmdW5jdGlvbiAoZWwsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm9uVXBkYXRlKGVsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShlbCwgaXRlbSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ub25BY3Rpdml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xvc3VyZSBhcm91bmQgdGhlIHNwYW4gb2YgdGhlIGN1cnJlbnQgYWN0aW9uLCB0aGVuIGV4ZWN1dGUgdGhlIG9uQWN0aXZpdHkgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdjdXJzb3JBY3Rpdml0eScsIChmdW5jdGlvbiAoZWwsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm9uQWN0aXZpdHkoZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGVsLCBpdGVtKSkpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBBcHBlbmQgdGhlIGl0ZW0gdG8gdGhlIHN0YXR1cyBiYXJcbiAgICAgICAgYmFyLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG5cblxuICAgIC8vIEluc2VydCB0aGUgc3RhdHVzIGJhciBpbnRvIHRoZSBET01cbiAgICB2YXIgY21XcmFwcGVyID0gdGhpcy5jb2RlbWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgY21XcmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJhciwgY21XcmFwcGVyLm5leHRTaWJsaW5nKTtcbiAgICByZXR1cm4gYmFyO1xufTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSB0ZXh0IGNvbnRlbnQuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNtLmdldFZhbHVlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY20uZ2V0RG9jKCkuc2V0VmFsdWUodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmV2aWV3QWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgcHJldmlld19yZXN1bHQgPSB0aGlzLm9wdGlvbnMucHJldmlld1JlbmRlcih2YWwsIHByZXZpZXcpO1xuICAgICAgICAgICAgaWYgKHByZXZpZXdfcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlldy5pbm5lckhUTUwgPSBwcmV2aWV3X3Jlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBCaW5kIHN0YXRpYyBtZXRob2RzIGZvciBleHBvcnRzLlxuICovXG5FYXN5TURFLnRvZ2dsZUJvbGQgPSB0b2dnbGVCb2xkO1xuRWFzeU1ERS50b2dnbGVJdGFsaWMgPSB0b2dnbGVJdGFsaWM7XG5FYXN5TURFLnRvZ2dsZVN0cmlrZXRocm91Z2ggPSB0b2dnbGVTdHJpa2V0aHJvdWdoO1xuRWFzeU1ERS50b2dnbGVCbG9ja3F1b3RlID0gdG9nZ2xlQmxvY2txdW90ZTtcbkVhc3lNREUudG9nZ2xlSGVhZGluZ1NtYWxsZXIgPSB0b2dnbGVIZWFkaW5nU21hbGxlcjtcbkVhc3lNREUudG9nZ2xlSGVhZGluZ0JpZ2dlciA9IHRvZ2dsZUhlYWRpbmdCaWdnZXI7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmcxID0gdG9nZ2xlSGVhZGluZzE7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmcyID0gdG9nZ2xlSGVhZGluZzI7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmczID0gdG9nZ2xlSGVhZGluZzM7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmc0ID0gdG9nZ2xlSGVhZGluZzQ7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmc1ID0gdG9nZ2xlSGVhZGluZzU7XG5FYXN5TURFLnRvZ2dsZUhlYWRpbmc2ID0gdG9nZ2xlSGVhZGluZzY7XG5FYXN5TURFLnRvZ2dsZUNvZGVCbG9jayA9IHRvZ2dsZUNvZGVCbG9jaztcbkVhc3lNREUudG9nZ2xlVW5vcmRlcmVkTGlzdCA9IHRvZ2dsZVVub3JkZXJlZExpc3Q7XG5FYXN5TURFLnRvZ2dsZU9yZGVyZWRMaXN0ID0gdG9nZ2xlT3JkZXJlZExpc3Q7XG5FYXN5TURFLmNsZWFuQmxvY2sgPSBjbGVhbkJsb2NrO1xuRWFzeU1ERS5kcmF3TGluayA9IGRyYXdMaW5rO1xuRWFzeU1ERS5kcmF3SW1hZ2UgPSBkcmF3SW1hZ2U7XG5FYXN5TURFLmRyYXdVcGxvYWRlZEltYWdlID0gZHJhd1VwbG9hZGVkSW1hZ2U7XG5FYXN5TURFLmRyYXdUYWJsZSA9IGRyYXdUYWJsZTtcbkVhc3lNREUuZHJhd0hvcml6b250YWxSdWxlID0gZHJhd0hvcml6b250YWxSdWxlO1xuRWFzeU1ERS51bmRvID0gdW5kbztcbkVhc3lNREUucmVkbyA9IHJlZG87XG5FYXN5TURFLnRvZ2dsZVByZXZpZXcgPSB0b2dnbGVQcmV2aWV3O1xuRWFzeU1ERS50b2dnbGVTaWRlQnlTaWRlID0gdG9nZ2xlU2lkZUJ5U2lkZTtcbkVhc3lNREUudG9nZ2xlRnVsbFNjcmVlbiA9IHRvZ2dsZUZ1bGxTY3JlZW47XG5cbi8qKlxuICogQmluZCBpbnN0YW5jZSBtZXRob2RzIGZvciBleHBvcnRzLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVCb2xkID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUJvbGQodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSXRhbGljID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUl0YWxpYyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVTdHJpa2V0aHJvdWdoID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZVN0cmlrZXRocm91Z2godGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlQmxvY2txdW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVCbG9ja3F1b3RlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmdTbWFsbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmdTbWFsbGVyKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmdCaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZ0JpZ2dlcih0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nMSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nMSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nMiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nMih0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nMyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nMyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nNCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nNCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nNSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nNSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVIZWFkaW5nNiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nNih0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVDb2RlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlQ29kZUJsb2NrKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVVub3JkZXJlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlVW5vcmRlcmVkTGlzdCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVPcmRlcmVkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVPcmRlcmVkTGlzdCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5jbGVhbkJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFuQmxvY2sodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd0xpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd0xpbmsodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd0ltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdJbWFnZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3VXBsb2FkZWRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3VXBsb2FkZWRJbWFnZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd1RhYmxlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdIb3Jpem9udGFsUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3SG9yaXpvbnRhbFJ1bGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB1bmRvKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVkbyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVQcmV2aWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZVByZXZpZXcodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlU2lkZUJ5U2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVTaWRlQnlTaWRlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlRnVsbFNjcmVlbih0aGlzKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmlzUHJldmlld0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5sYXN0Q2hpbGQ7XG5cbiAgICByZXR1cm4gcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuaXNTaWRlQnlTaWRlQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuXG4gICAgcmV0dXJuIHByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuaXNGdWxsc2NyZWVuQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcblxuICAgIHJldHVybiBjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcblxuICAgIHJldHVybiBnZXRTdGF0ZShjbSk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIGVhc3lNREVDb250YWluZXIgPSB3cmFwcGVyLnBhcmVudE5vZGU7XG5cbiAgICBpZiAoZWFzeU1ERUNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5ndWkudG9vbGJhcikge1xuICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmd1aS50b29sYmFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ndWkuc3RhdHVzYmFyKSB7XG4gICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZ3VpLnN0YXR1c2Jhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3VpLnNpZGVCeVNpZGUpIHtcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ndWkuc2lkZUJ5U2lkZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbndyYXAgZWFzeU1ERWNvbnRhaW5lciBiZWZvcmUgY29kZW1pcnJvciB0b1RleHRBcmVhKCkgY2FsbFxuICAgIGVhc3lNREVDb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgZWFzeU1ERUNvbnRhaW5lcik7XG4gICAgZWFzeU1ERUNvbnRhaW5lci5yZW1vdmUoKTtcblxuICAgIGNtLnRvVGV4dEFyZWEoKTtcblxuICAgIGlmICh0aGlzLmF1dG9zYXZlVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9zYXZlVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5hdXRvc2F2ZVRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGVhckF1dG9zYXZlZFZhbHVlKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFYXN5TURFO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/easymde.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/dist/easymde.min.css":
/*!***************************************************!*\
  !*** ./node_modules/easymde/dist/easymde.min.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"17bd888c94c1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9kaXN0L2Vhc3ltZGUubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2lzc3VlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9kaXN0L2Vhc3ltZGUubWluLmNzcz9lZmUwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMTdiZDg4OGM5NGMxXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/dist/easymde.min.css\n");

/***/ })

};
;